{
  "comments": [
    {
      "key": {
        "uuid": "8bce76f6_9ed9c66d",
        "filename": "src/FSAL/FSAL_VFS/vfs/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2018-10-04T22:45:34Z",
      "side": 1,
      "message": "If we reorder fsals after MainNFSD we should be able to use ganesha_nfsd directly, that will let cmake order the dependencies properly. I\u0027m worried this might lead to a FSAL being compiled too early on a clean build and failing build.",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e1a80db_c59b19f8",
        "filename": "src/FSAL/FSAL_VFS/vfs/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1004389
      },
      "writtenOn": "2018-10-05T02:08:13Z",
      "side": 1,
      "message": "When I used just \u0027ganesha_nfsd\u0027 here, not only did it link with libganesha_nsfd.so, but with all the .a libs that make up libganesha_nfsd.so. Perhaps someone who knows cmake better than I  knows how to do this so that it doesn\u0027t link with all the .a libs.\n\nI\u0027m not a cmake expert so I\u0027m not sure what exactly you mean by reorder the fsals. I did move the FSALS subdir after MainNFSD in the top-level CMakeLists.txt. Is that not what you\u0027re suggesting.",
      "parentUuid": "8bce76f6_9ed9c66d",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4493b9c4_9163420b",
        "filename": "src/FSAL/FSAL_VFS/vfs/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2018-10-05T02:23:18Z",
      "side": 1,
      "message": "Yeah that\u0027s the reorderign I meant, sorry I didn\u0027t check - I thought that\u0027d be enough.\nIf it links with the static intermediate libs as well it\u0027s not what we want I agree, will need to think about that...",
      "parentUuid": "4e1a80db_c59b19f8",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "caf38434_01f1bb71",
        "filename": "src/MainNFSD/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2018-10-04T22:45:34Z",
      "side": 1,
      "message": "This feels a bit weird to have to turn this on for all targets, I wonder if we\u0027re missing something..",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ba465e3_53a95688",
        "filename": "src/MainNFSD/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1004389
      },
      "writtenOn": "2018-10-05T02:08:13Z",
      "side": 1,
      "message": "No, it\u0027s really not that strange. And it\u0027s actually not _every_ target. Everything going into a DSO needs to be compiled with -fPIC. We just don\u0027t have very many targets that aren\u0027t going into the DSO.\n\nIt\u0027s only unusual in the sense that historically we have bundled things up into .a libs. To create a DSO many people would probably skip the .a libs and link all the .o files to make the .so. I didn\u0027t want to retool all of that.\n\nAnd maybe is seems strange to put PIC files into a .a lib, but on some arches, e.g. MIPS, everything is compiled PIC, even if it\u0027s for an executable for a static lib.",
      "parentUuid": "caf38434_01f1bb71",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a678d00d_829da5f5",
        "filename": "src/MainNFSD/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2018-10-05T02:23:18Z",
      "side": 1,
      "message": "No, that\u0027s not what I find strange - I know why we need PIC here (and I understand it\u0027s not actually every target); I just find it strange that there isn\u0027t a more \"natural\" way of doing that with cmake, I don\u0027t think what we\u0027re trying to do here (compile files from multiple subdirs into a single .so) is that unusual...\n\nTogether with the other linking in the fsal you had to do manually I think maybe we just shouldn\u0027t define the subtargets, and point all the sources to the new ganesha_nfsd shared lib -- that way cmake will turn fPIC on automatically (along with other shared-lib only specific things if there are more), it\u0027ll do the dependencies I was worried about, and the result should be pretty much the same.\nThe question I have is if we can just set(foo_SRCS) in one directory as relative path and use it in another and cmake would figure it out, I guess we\u0027d have to try... I got spoiled with meson lately so it\u0027s hard coming back to cmake :P",
      "parentUuid": "5ba465e3_53a95688",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8fb8cd4f_f8085509",
        "filename": "src/MainNFSD/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 108,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2018-10-04T22:45:34Z",
      "side": 1,
      "message": "I think we should be more strict than this somehow, to avoid problems where someone has a local \u0027make install\u0027 in some directory, rpm in another and dynamic linker takes the wrong libganesha_nfsd.so...\nWe can\u0027t really do that with SOVERSION but some version check in nfs_prereq_init or nfs_init_init might be useful - for example add an argument that takes some version string we\u0027d pass in main() and strcmp it in the function to make sure the build matches (not sure what to use for that string though, checksum of make dist? Unless we also make a .syms file but that will probably be some work to keep up to date)",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4edc60c_7cae7597",
        "filename": "src/MainNFSD/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 108,
      "author": {
        "id": 1004389
      },
      "writtenOn": "2018-10-05T02:08:13Z",
      "side": 1,
      "message": "ELF does all that for you already. The compile-time linker links with libganesha_nfsd.so (a symlink to libganesha_nfsd.so.2.7.) The SO_NAME in the DSO is \"libganesha_nfsd.so.2.7; you can see this with `objdump -x libganesha_nfsd.so(.2.7) The compile-time linker records the SO_NAME in executable (ganesha.nsfd); you can see this with ldd or objdump.\n\nAt runtime, the RTlinker reads the SO_NAME recorded in the executable (libganesha_nfsd.so.2.7) and loads the exact DSO (from the DSOs in the ld.so.cache). And IIRC also verifies that the SO_NAME in the DSO matches. If you have a libganesha_nfsd.so.2.8 on the box, the RTlinker won\u0027t use it, even if you rename it to libganesha_nfsd.so.2.7.\n\nBuilding the DSO with a .sym file is the next level. You find out pretty quickly when you forget to add a new symbol to the .sym file. It\u0027s really not as burdensome as you might think to keep it in sync. And using it makes you think carefully (sometimes) about adding new APIs.\n\nAnd the next level after that is to use versioned symbols. Using versioned symbols is slightly more work to maintain in the simple case where you don\u0027t change the API/ABI. It starts to be real work when you change parameters to functions. I\u0027m not convinced we would ever need or want to go to that level.",
      "parentUuid": "8fb8cd4f_f8085509",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d1cade07_a91eb82c",
        "filename": "src/MainNFSD/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 108,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2018-10-05T02:23:18Z",
      "side": 1,
      "message": "No, as far as I understand things the only thing ld checks if the first digit (e.g. see so_name bumps on fedora-devel - foo.so.2.7 and foo.so.2.8 are compatible; you can confirm with ldd on the binary it only links with foo.so.2)\n\nLinking with a .sym file won\u0027t solve that, but it will give a good thing to verify (e.g. as long as the .sym file didn\u0027t change it\u0027s probably fine even if we load a slightly different lib... even if it\u0027s probably not great)\n\nUltimately it\u0027s users hygiene and we can\u0027t (and generally I don\u0027t like to try to) prevent users from shooting themselves in the foot, but this feels like something users might run into",
      "parentUuid": "f4edc60c_7cae7597",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a5fd822_9b870a81",
        "filename": "src/MainNFSD/CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 108,
      "author": {
        "id": 1004389
      },
      "writtenOn": "2018-10-05T10:47:38Z",
      "side": 1,
      "message": "As it is now – in this patch – there is no libganesha_nfsd.so.2 and objdump and ldd and strace show that the executable links at runtime explicitly with libganesha_nfsd.so.2.7, not with libganesha_nfsd.so.2.\n\nThe SO_NAME is just a string. If the SO_NAME in the library is libganesha_nfsd.so.renault then that\u0027s what recorded in the executable and that\u0027s what is linked at runtime. (But the convention is that numbers are used.)\n\nIt is possible to make DSOs named libganesha_nfsd.so.2.[789...] that have an SO_NAME libganesha_nfsd.so.2 (and create the symlink libganesha_nfsd.so.2 -\u003e libganesha_nfsd.so.2.[780]) which would behave the way you describe. But this patch doesn\u0027t do that.\n\nThis has been true of ELF DSOs for a long as I\u0027ve been writing software on Unix and Linux, over 25 years now. Also SunOS 4, which had similar, if not exactly the same shared library semantics going back nearly 30 years. \n\nDo give it a try, don\u0027t just take my word. (Even though I\u0027ve been doing this for a long time. :-))",
      "parentUuid": "d1cade07_a91eb82c",
      "revId": "57e097725f97c8068d6c28aea73488c0c1c33da1",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}