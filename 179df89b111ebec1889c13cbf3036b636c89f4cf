{
  "comments": [
    {
      "key": {
        "uuid": "f4bcd74d_38d36a33",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1003947
      },
      "writtenOn": "2019-12-11T10:45:35Z",
      "side": 1,
      "message": "Looks like the \"obj\" is getting freed here due to its refcount going to zero?  We do hold obj-\u003estate_hdl-\u003estate_lock while calling this function. The caller will access the lock to unlock which should have been freed here, correct?",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3b0cb17_66f2afc2",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1004087
      },
      "writtenOn": "2019-12-11T13:53:41Z",
      "side": 1,
      "message": "This raises an interesting point.  Yes, the state_lock *should* be held on this obj, but I\u0027m not sure it is in this case.  The call stack here comes from nfs4_op_close(), which got it\u0027s state from nfs4_Check_Stateid().  This looks up a state by ID, with no reference to the obj that owns it.  It *should* be owned by data-\u003ecurrent_obj.  It gets a ref on the actual owner obj, but drops it again quickly.  What if the stateID doesn\u0027t match a state on the current object?",
      "parentUuid": "f4bcd74d_38d36a33",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbc8cab2_eaecc1b1",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1003947
      },
      "writtenOn": "2019-12-11T15:01:02Z",
      "side": 1,
      "message": "Should we do pointer comparison of obj and obj2 instead of the following? The following check does compare file handles, so this is an issue if there are multiple objects with same handle (which was true with GPFS in the past, but at least we tried to avoid in 2.7).\n\n/* Sanity check : Is this the right file ? */\n        if (fsal_obj \u0026\u0026 !fsal_obj-\u003eobj_ops-\u003ehandle_cmp(fsal_obj, obj2)) {",
      "parentUuid": "a3b0cb17_66f2afc2",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c329bdbe_b39e4aa2",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1004087
      },
      "writtenOn": "2019-12-11T18:08:31Z",
      "side": 1,
      "message": "I think the issue may be this:  The handle was made invalid (mdcache_kill_entry() was called).  Usually, this is because of something the FSAL did, like return EINVAL.  However, something was using the handle, so it wasn\u0027t immediately cleaned up.  A new close op came in, and the putfh associated with it made a new handle (since the old one was unlinked).  It then looked up the state ID, and got back the old handle (linked from the state).  Therefore, the state lock and ref that nfs4_op_close() kept on the new handle didn\u0027t protect the old handle, which was freed as soon as the state\u0027s last ref was dropped.\n\nDoes this seem sane?  If so, I think we need to return the correct handle out of nfs4_Check_Stateid(), and keep a ref on it, and use it for locking.",
      "parentUuid": "bbc8cab2_eaecc1b1",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1178917d_46283776",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1003947
      },
      "writtenOn": "2019-12-12T05:20:36Z",
      "side": 1,
      "message": "The obj and data-\u003ecurrent_obj are indeed different from the crash, but have same fileid (inode). Will look at it further.",
      "parentUuid": "bbc8cab2_eaecc1b1",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15688f2d_f910bd3f",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1003947
      },
      "writtenOn": "2019-12-12T05:35:35Z",
      "side": 1,
      "message": "I was thinking the same about a file being deleted before the close may get us into this or some other scenario. Should we just call set_current_entry(data, obj2) if they differ in nfs4_Check_Stateid()?",
      "parentUuid": "1178917d_46283776",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d03deb05_ecc4ee19",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2019-12-12T18:14:32Z",
      "side": 1,
      "message": "Some thoughts here:\n1. The caller of nfs4_Check_Stateid doesn\u0027t always pass data-\u003ecurrent_obj, sometimes it passes obj which has been set from data-\u003ecurrent_obj, so if you changed that, there might be problems, we\u0027d need to fix all those callers.\n\n2. If fsal_obj (which is either NULL, obj, or data-\u003ecurrent_obj) doesn\u0027t match obj2 because a new object got created when the old one went stale, maybe the stateid should be made stale also? So if fsal_obj is non-NULL and doesn\u0027t match obj2, maybe that\u0027s a stale stateid?\n\nHmm, the handle_cmp was introduced during the conversion of cache_inode to FSAL_MDCACHE... \n\nIn commit: cafbe60c47c4ed4ac4abe8f78083d88f4e5bbbec - Napalm - Rip out cache_inode\nsee:\n        /* Sanity check : Is this the right file ? */\n-       if ((entry !\u003d NULL) \u0026\u0026 (entry2 !\u003d entry)) {\n+       if (fsal_obj \u0026\u0026 !fsal_obj-\u003eobj_ops.handle_cmp(fsal_obj, obj2)) {\n\nI think we can safely revert to a pointer comparison. This is all at the protocol level and this should only ever have MDCACHE objs.",
      "parentUuid": "15688f2d_f910bd3f",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1991ddf6_cbef18b7",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1004087
      },
      "writtenOn": "2019-12-12T18:25:22Z",
      "side": 1,
      "message": "Apparently I never posted my last comment.  \u003csigh\u003e  I wasn\u0027t planning on changing current_obj, I don\u0027t think we should ever change that outside of putfh.  I was planning on adding another returned obj, that the caller would be responsible for putting the ref on it.\n\nThe handle_cmp was specifically added to handle the case where the handle changed for some reason between calls.  I believe that was before the state kept a ref on the obj, but in this case, I think it\u0027s still doing the right thing.\n\nI don\u0027t think we want to return an error, I think we want to close the state on the old handle, so we don\u0027t leak handles (and FDs).",
      "parentUuid": "d03deb05_ecc4ee19",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}