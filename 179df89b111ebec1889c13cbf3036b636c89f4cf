{
  "comments": [
    {
      "key": {
        "uuid": "f4bcd74d_38d36a33",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1003947
      },
      "writtenOn": "2019-12-11T10:45:35Z",
      "side": 1,
      "message": "Looks like the \"obj\" is getting freed here due to its refcount going to zero?  We do hold obj-\u003estate_hdl-\u003estate_lock while calling this function. The caller will access the lock to unlock which should have been freed here, correct?",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3b0cb17_66f2afc2",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1004087
      },
      "writtenOn": "2019-12-11T13:53:41Z",
      "side": 1,
      "message": "This raises an interesting point.  Yes, the state_lock *should* be held on this obj, but I\u0027m not sure it is in this case.  The call stack here comes from nfs4_op_close(), which got it\u0027s state from nfs4_Check_Stateid().  This looks up a state by ID, with no reference to the obj that owns it.  It *should* be owned by data-\u003ecurrent_obj.  It gets a ref on the actual owner obj, but drops it again quickly.  What if the stateID doesn\u0027t match a state on the current object?",
      "parentUuid": "f4bcd74d_38d36a33",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbc8cab2_eaecc1b1",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1003947
      },
      "writtenOn": "2019-12-11T15:01:02Z",
      "side": 1,
      "message": "Should we do pointer comparison of obj and obj2 instead of the following? The following check does compare file handles, so this is an issue if there are multiple objects with same handle (which was true with GPFS in the past, but at least we tried to avoid in 2.7).\n\n/* Sanity check : Is this the right file ? */\n        if (fsal_obj \u0026\u0026 !fsal_obj-\u003eobj_ops-\u003ehandle_cmp(fsal_obj, obj2)) {",
      "parentUuid": "a3b0cb17_66f2afc2",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c329bdbe_b39e4aa2",
        "filename": "src/SAL/nfs4_state.c",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 1004087
      },
      "writtenOn": "2019-12-11T18:08:31Z",
      "side": 1,
      "message": "I think the issue may be this:  The handle was made invalid (mdcache_kill_entry() was called).  Usually, this is because of something the FSAL did, like return EINVAL.  However, something was using the handle, so it wasn\u0027t immediately cleaned up.  A new close op came in, and the putfh associated with it made a new handle (since the old one was unlinked).  It then looked up the state ID, and got back the old handle (linked from the state).  Therefore, the state lock and ref that nfs4_op_close() kept on the new handle didn\u0027t protect the old handle, which was freed as soon as the state\u0027s last ref was dropped.\n\nDoes this seem sane?  If so, I think we need to return the correct handle out of nfs4_Check_Stateid(), and keep a ref on it, and use it for locking.",
      "parentUuid": "bbc8cab2_eaecc1b1",
      "revId": "179df89b111ebec1889c13cbf3036b636c89f4cf",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}