/*
 * The content of this file is a mix of rpcgen-generated
 * and hand-edited program text.  It is not automatically
 * generated by, e.g., build processes.
 *
 * This file is under version control.
 */

#ifndef _GSH_NFSV41_XDR_H_RPCGEN
#define _GSH_NFSV41_XDR_H_RPCGEN

#include "nfs_fh.h"

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__STDC__) || defined(__cplusplus)
#define NFSPROC4_NULL 0
	extern void *nfsproc4_null_4(void *, CLIENT*);
	extern void *nfsproc4_null_4_svc(void *, struct svc_req *);
#define NFSPROC4_COMPOUND 1
	extern COMPOUND4res *nfsproc4_compound_4(COMPOUND4args *, CLIENT*);
	extern COMPOUND4res *nfsproc4_compound_4_svc(COMPOUND4args *,
						     struct svc_req *);
	extern int nfs4_program_4_freeresult(SVCXPRT *, xdrproc_t, caddr_t);

#else				/* K&R C */
#define NFSPROC4_NULL 0
	extern void *nfsproc4_null_4();
	extern void *nfsproc4_null_4_svc();
#define NFSPROC4_COMPOUND 1
	extern COMPOUND4res *nfsproc4_compound_4();
	extern COMPOUND4res *nfsproc4_compound_4_svc();
	extern int nfs4_program_4_freeresult();
#endif				/* K&R C */

#define NFS4_CALLBACK 0x40000000
#define NFS_CB 1

#if defined(__STDC__) || defined(__cplusplus)
#define CB_NULL 0
	extern void *cb_null_1(void *, CLIENT*);
	extern void *cb_null_1_svc(void *, struct svc_req *);
#define CB_COMPOUND 1
	extern CB_COMPOUND4res *cb_compound_1(CB_COMPOUND4args *, CLIENT*);
	extern CB_COMPOUND4res *cb_compound_1_svc(CB_COMPOUND4args *,
						  struct svc_req *);
	extern int nfs4_callback_1_freeresult(SVCXPRT *, xdrproc_t, caddr_t);

#else				/* K&R C */
#define CB_NULL 0
	extern void *cb_null_1();
	extern void *cb_null_1_svc();
#define CB_COMPOUND 1
	extern CB_COMPOUND4res *cb_compound_1();
	extern CB_COMPOUND4res *cb_compound_1_svc();
	extern int nfs4_callback_1_freeresult();
#endif				/* K&R C */

/* the xdr functions */

#if defined(__STDC__) || defined(__cplusplus)

	static inline bool xdr_nfs_ftype4(XDR * xdrs, nfs_ftype4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_nfsstat4(XDR * xdrs, nfsstat4 * objp)

	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_attrlist4(XDR * xdrs, attrlist4 * objp)
	{
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->attrlist4_val,
		     (u_int *) &objp->attrlist4_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_bitmap4(XDR * xdrs, struct bitmap4 *objp)
	{
		char *map = (char *)objp->map;

/* short circuit the free pass (done at the end) because we don't
 * allocate an array in the "conventional" sense here.  There is
 * nothing to free so bail out now.
 */
		if (xdrs->x_op == XDR_FREE)
			return true;
		if (!xdr_array
		    (xdrs, &map, (u_int *) &objp->bitmap4_len, ~0,
		     sizeof(uint32_t), (xdrproc_t) xdr_uint32_t))
			return false;
		return true;
	}

	static inline bool xdr_changeid4(XDR * xdrs, changeid4 * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_clientid4(XDR * xdrs, clientid4 * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_count4(XDR * xdrs, count4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_length4(XDR * xdrs, length4 * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_mode4(XDR * xdrs, mode4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_nfs_cookie4(XDR * xdrs, nfs_cookie4 * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_nfs_fh4(XDR * xdrs, nfs_fh4 * objp)
	{
		file_handle_v4_t *fh;
		fh = (file_handle_v4_t *)objp->nfs_fh4_val;

		if (xdrs->x_op == XDR_ENCODE)
			fh->id.exports = htons(fh->id.exports);

		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->nfs_fh4_val,
		     (u_int *) &objp->nfs_fh4_len, NFS4_FHSIZE))
			return false;

		if (xdrs->x_op == XDR_DECODE)
			fh->id.exports = ntohs(fh->id.exports);

		return true;
	}

	static inline bool xdr_offset4(XDR * xdrs, offset4 * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_qop4(XDR * xdrs, qop4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_sec_oid4(XDR * xdrs, sec_oid4 * objp)
	{
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->sec_oid4_val,
		     (u_int *) &objp->sec_oid4_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_sequenceid4(XDR * xdrs, sequenceid4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_seqid4(XDR * xdrs, seqid4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_sessionid4(XDR * xdrs, sessionid4 objp)
	{
		if (!xdr_opaque(xdrs, objp, NFS4_SESSIONID_SIZE))
			return false;
		return true;
	}

	static inline bool xdr_slotid4(XDR * xdrs, slotid4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_utf8string(XDR * xdrs, utf8string * objp)
	{
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->utf8string_val,
		     (u_int *) &objp->utf8string_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_utf8str_cis(XDR * xdrs, utf8str_cis * objp)
	{
		if (!xdr_utf8string(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_utf8str_cs(XDR * xdrs, utf8str_cs * objp)
	{
		if (!xdr_utf8string(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_utf8str_mixed(XDR * xdrs, utf8str_mixed * objp)
	{
		if (!xdr_utf8string(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_component4(XDR * xdrs, component4 * objp)
	{
		if (!xdr_utf8str_cs(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_linktext4(XDR * xdrs, linktext4 * objp)
	{
		if (!xdr_utf8str_cs(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_pathname4(XDR * xdrs, pathname4 * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->pathname4_val,
		     (u_int *) &objp->pathname4_len, ~0, sizeof(component4),
		     (xdrproc_t) xdr_component4))
			return false;
		return true;
	}

	static inline bool xdr_verifier4(XDR * xdrs, verifier4 objp)
	{
		if (!xdr_opaque(xdrs, objp, NFS4_VERIFIER_SIZE))
			return false;
		return true;
	}

	static inline bool xdr_nfstime4(XDR * xdrs, nfstime4 * objp)
	{
		if (!xdr_int64_t(xdrs, &objp->seconds))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->nseconds))
			return false;
		return true;
	}

	static inline bool xdr_time_how4(XDR * xdrs, time_how4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_settime4(XDR * xdrs, settime4 * objp)
	{
		if (!xdr_time_how4(xdrs, &objp->set_it))
			return false;
		switch (objp->set_it) {
		case SET_TO_CLIENT_TIME4:
			if (!xdr_nfstime4(xdrs, &objp->settime4_u.time))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_nfs_lease4(XDR * xdrs, nfs_lease4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fsid4(XDR * xdrs, fsid4 * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, &objp->major))
			return false;
		if (!inline_xdr_u_int64_t(xdrs, &objp->minor))
			return false;
		return true;
	}

	static inline bool xdr_change_policy4(XDR * xdrs, change_policy4 * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, &objp->cp_major))
			return false;
		if (!inline_xdr_u_int64_t(xdrs, &objp->cp_minor))
			return false;
		return true;
	}

	static inline bool xdr_fs_location4(XDR * xdrs, fs_location4 * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->server.server_val,
		     (u_int *) &objp->server.server_len, ~0,
		     sizeof(utf8str_cis), (xdrproc_t) xdr_utf8str_cis))
			return false;
		if (!xdr_pathname4(xdrs, &objp->rootpath))
			return false;
		return true;
	}

	static inline bool xdr_fs_locations4(XDR * xdrs, fs_locations4 * objp)
	{
		if (!xdr_pathname4(xdrs, &objp->fs_root))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->locations.locations_val,
		     (u_int *) &objp->locations.locations_len, ~0,
		     sizeof(fs_location4), (xdrproc_t) xdr_fs_location4))
			return false;
		return true;
	}

	static inline bool xdr_acetype4(XDR * xdrs, acetype4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_aceflag4(XDR * xdrs, aceflag4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_acemask4(XDR * xdrs, acemask4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_nfsace4(XDR * xdrs, nfsace4 * objp)
	{
		if (!xdr_acetype4(xdrs, &objp->type))
			return false;
		if (!xdr_aceflag4(xdrs, &objp->flag))
			return false;
		if (!xdr_acemask4(xdrs, &objp->access_mask))
			return false;
		if (!xdr_utf8str_mixed(xdrs, &objp->who))
			return false;
		return true;
	}

	static inline bool xdr_aclflag4(XDR * xdrs, aclflag4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_nfsacl41(XDR * xdrs, nfsacl41 * objp)
	{
		if (!xdr_aclflag4(xdrs, &objp->na41_flag))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->na41_aces.na41_aces_val,
		     (u_int *) &objp->na41_aces.na41_aces_len, ~0,
		     sizeof(nfsace4), (xdrproc_t) xdr_nfsace4))
			return false;
		return true;
	}

	static inline bool xdr_mode_masked4(XDR * xdrs, mode_masked4 * objp)
	{
		if (!xdr_mode4(xdrs, &objp->mm_value_to_set))
			return false;
		if (!xdr_mode4(xdrs, &objp->mm_mask_bits))
			return false;
		return true;
	}

	static inline bool xdr_specdata4(XDR * xdrs, specdata4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->specdata1))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->specdata2))
			return false;
		return true;
	}

	static inline bool xdr_netaddr4(XDR * xdrs, netaddr4 * objp)
	{
		if (!inline_xdr_string(xdrs, &objp->r_netid, ~0))
			return false;
		if (!inline_xdr_string(xdrs, &objp->r_addr, ~0))
			return false;
		return true;
	}

	static inline bool xdr_nfs_impl_id4(XDR * xdrs, nfs_impl_id4 * objp)
	{
		if (!xdr_utf8str_cis(xdrs, &objp->nii_domain))
			return false;
		if (!xdr_utf8str_cs(xdrs, &objp->nii_name))
			return false;
		if (!xdr_nfstime4(xdrs, &objp->nii_date))
			return false;
		return true;
	}

	static inline bool xdr_stateid4(XDR * xdrs, stateid4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->seqid))
			return false;
		if (!xdr_opaque(xdrs, objp->other, 12))
			return false;
		return true;
	}

	static inline bool xdr_layouttype4(XDR * xdrs, layouttype4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_layout_content4(XDR * xdrs,
					       layout_content4 * objp)
	{
		if (!xdr_layouttype4(xdrs, &objp->loc_type))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->loc_body.loc_body_val,
		     (u_int *) &objp->loc_body.loc_body_len, ~0))
			return false;
		return true;
	}

/*
 * LAYOUT4_OSD2_OBJECTS loc_body description
 * is in a separate .x file
 */

/*
 * LAYOUT4_BLOCK_VOLUME loc_body description
 * is in a separate .x file
 */

	static inline bool xdr_layouthint4(XDR * xdrs, layouthint4 * objp)
	{
		if (!xdr_layouttype4(xdrs, &objp->loh_type))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->loh_body.loh_body_val,
		     (u_int *) &objp->loh_body.loh_body_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_layoutiomode4(XDR * xdrs, layoutiomode4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_layout4(XDR * xdrs, layout4 * objp)
	{
		if (!xdr_offset4(xdrs, &objp->lo_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->lo_length))
			return false;
		if (!xdr_layoutiomode4(xdrs, &objp->lo_iomode))
			return false;
		if (!xdr_layout_content4(xdrs, &objp->lo_content))
			return false;
		return true;
	}

	static inline bool xdr_deviceid4(XDR * xdrs, deviceid4 objp)
	{
		if (!xdr_opaque(xdrs, objp, NFS4_DEVICEID4_SIZE))
			return false;
		return true;
	}

	static inline bool xdr_device_addr4(XDR * xdrs, device_addr4 * objp)
	{
		if (!xdr_layouttype4(xdrs, &objp->da_layout_type))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->da_addr_body.da_addr_body_val,
		     (u_int *) &objp->da_addr_body.da_addr_body_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_layoutupdate4(XDR * xdrs, layoutupdate4 * objp)
	{
		if (!xdr_layouttype4(xdrs, &objp->lou_type))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->lou_body.lou_body_val,
		     (u_int *) &objp->lou_body.lou_body_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_layoutreturn_type4(XDR * xdrs,
						  layoutreturn_type4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	/* layouttype4 specific data */

	static inline bool xdr_layoutreturn_file4(XDR * xdrs,
						  layoutreturn_file4 * objp)
	{
		if (!xdr_offset4(xdrs, &objp->lrf_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->lrf_length))
			return false;
		if (!xdr_stateid4(xdrs, &objp->lrf_stateid))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->lrf_body.lrf_body_val,
		     (u_int *) &objp->lrf_body.lrf_body_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_layoutreturn4(XDR * xdrs, layoutreturn4 * objp)
	{
		if (!xdr_layoutreturn_type4(xdrs, &objp->lr_returntype))
			return false;
		switch (objp->lr_returntype) {
		case LAYOUTRETURN4_FILE:
			if (!xdr_layoutreturn_file4
			    (xdrs, &objp->layoutreturn4_u.lr_layout))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_fs4_status_type(XDR * xdrs,
					       fs4_status_type * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_fs4_status(XDR * xdrs, fs4_status * objp)
	{
		if (!xdr_bool(xdrs, &objp->fss_absent))
			return false;
		if (!xdr_fs4_status_type(xdrs, &objp->fss_type))
			return false;
		if (!xdr_utf8str_cs(xdrs, &objp->fss_source))
			return false;
		if (!xdr_utf8str_cs(xdrs, &objp->fss_current))
			return false;
		if (!xdr_int32_t(xdrs, &objp->fss_age))
			return false;
		if (!xdr_nfstime4(xdrs, &objp->fss_version))
			return false;
		return true;
	}

	static inline bool xdr_threshold4_read_size(XDR * xdrs,
						    threshold4_read_size *
						    objp)
	{
		if (!xdr_length4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_threshold4_write_size(XDR * xdrs,
						     threshold4_write_size *
						     objp)
	{
		if (!xdr_length4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_threshold4_read_iosize(XDR * xdrs,
						      threshold4_read_iosize *
						      objp)
	{
		if (!xdr_length4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_threshold4_write_iosize(XDR * xdrs,
						       threshold4_write_iosize *
						       objp)
	{
		if (!xdr_length4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_threshold_item4(XDR * xdrs,
					       threshold_item4 * objp)
	{
		if (!xdr_layouttype4(xdrs, &objp->thi_layout_type))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->thi_hintset))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->thi_hintlist.thi_hintlist_val,
		     (u_int *) &objp->thi_hintlist.thi_hintlist_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_mdsthreshold4(XDR * xdrs, mdsthreshold4 * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->mth_hints.mth_hints_val,
		     (u_int *) &objp->mth_hints.mth_hints_len, ~0,
		     sizeof(threshold_item4), (xdrproc_t) xdr_threshold_item4))
			return false;
		return true;
	}

	static inline bool xdr_retention_get4(XDR * xdrs, retention_get4 * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, &objp->rg_duration))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->rg_begin_time.rg_begin_time_val,
		     (u_int *) &objp->rg_begin_time.rg_begin_time_len, 1,
		     sizeof(nfstime4), (xdrproc_t) xdr_nfstime4))
			return false;
		return true;
	}

	static inline bool xdr_retention_set4(XDR * xdrs, retention_set4 * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->rs_enable))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->rs_duration.rs_duration_val,
		     (u_int *) &objp->rs_duration.rs_duration_len, 1,
		     sizeof(uint64_t), (xdrproc_t) inline_xdr_u_int64_t))
			return false;
		return true;
	}

	static inline bool xdr_fs_charset_cap4(XDR * xdrs,
					       fs_charset_cap4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_supported_attrs(XDR * xdrs,
						      fattr4_supported_attrs *
						      objp)
	{
		if (!xdr_bitmap4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_type(XDR * xdrs, fattr4_type * objp)
	{
		if (!xdr_nfs_ftype4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_fh_expire_type(XDR * xdrs,
						     fattr4_fh_expire_type *
						     objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_change(XDR * xdrs, fattr4_change * objp)
	{
		if (!xdr_changeid4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_size(XDR * xdrs, fattr4_size * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_link_support(XDR * xdrs,
						   fattr4_link_support * objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_symlink_support(XDR * xdrs,
						      fattr4_symlink_support *
						      objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_named_attr(XDR * xdrs,
						 fattr4_named_attr * objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_fsid(XDR * xdrs, fattr4_fsid * objp)
	{
		if (!xdr_fsid4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_unique_handles(XDR * xdrs,
						     fattr4_unique_handles *
						     objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_lease_time(XDR * xdrs,
						 fattr4_lease_time * objp)
	{
		if (!xdr_nfs_lease4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_rdattr_error(XDR * xdrs,
						   fattr4_rdattr_error * objp)
	{
		if (!xdr_nfsstat4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_acl(XDR * xdrs, fattr4_acl * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->fattr4_acl_val,
		     (u_int *) &objp->fattr4_acl_len, ~0, sizeof(nfsace4),
		     (xdrproc_t) xdr_nfsace4))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_aclsupport(XDR * xdrs,
						 fattr4_aclsupport * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_archive(XDR * xdrs, fattr4_archive * objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_cansettime(XDR * xdrs,
						 fattr4_cansettime * objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_case_insensitive(XDR * xdrs,
						       fattr4_case_insensitive *
						       objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_case_preserving(XDR * xdrs,
						      fattr4_case_preserving *
						      objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_chown_restricted(XDR * xdrs,
						       fattr4_chown_restricted *
						       objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_fileid(XDR * xdrs, fattr4_fileid * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_files_avail(XDR * xdrs,
						  fattr4_files_avail * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_filehandle(XDR * xdrs,
						 fattr4_filehandle * objp)
	{
		if (!xdr_nfs_fh4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_files_free(XDR * xdrs,
						 fattr4_files_free * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_files_total(XDR * xdrs,
						  fattr4_files_total * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_fs_locations(XDR * xdrs,
						   fattr4_fs_locations * objp)
	{
		if (!xdr_fs_locations4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_hidden(XDR * xdrs, fattr4_hidden * objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_homogeneous(XDR * xdrs,
						  fattr4_homogeneous * objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_maxfilesize(XDR * xdrs,
						  fattr4_maxfilesize * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_maxlink(XDR * xdrs, fattr4_maxlink * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_maxname(XDR * xdrs, fattr4_maxname * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_maxread(XDR * xdrs, fattr4_maxread * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_maxwrite(XDR * xdrs,
					       fattr4_maxwrite * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_mimetype(XDR * xdrs,
					       fattr4_mimetype * objp)
	{
		if (!xdr_utf8str_cs(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_mode(XDR * xdrs, fattr4_mode * objp)
	{
		if (!xdr_mode4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_mode_set_masked(XDR * xdrs,
						      fattr4_mode_set_masked *
						      objp)
	{
		if (!xdr_mode_masked4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_mounted_on_fileid(XDR * xdrs,
							fattr4_mounted_on_fileid
							* objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_no_trunc(XDR * xdrs,
					       fattr4_no_trunc * objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_numlinks(XDR * xdrs,
					       fattr4_numlinks * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_owner(XDR * xdrs, fattr4_owner * objp)
	{
		if (!xdr_utf8str_mixed(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_owner_group(XDR * xdrs,
						  fattr4_owner_group * objp)
	{
		if (!xdr_utf8str_mixed(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_quota_avail_hard(XDR * xdrs,
						       fattr4_quota_avail_hard *
						       objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_quota_avail_soft(XDR * xdrs,
						       fattr4_quota_avail_soft *
						       objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_quota_used(XDR * xdrs,
						 fattr4_quota_used * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_rawdev(XDR * xdrs, fattr4_rawdev * objp)
	{
		if (!xdr_specdata4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_space_avail(XDR * xdrs,
						  fattr4_space_avail * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_space_free(XDR * xdrs,
						 fattr4_space_free * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_space_total(XDR * xdrs,
						  fattr4_space_total * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_space_used(XDR * xdrs,
						 fattr4_space_used * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_system(XDR * xdrs, fattr4_system * objp)
	{
		if (!inline_xdr_bool(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_time_access(XDR * xdrs,
						  fattr4_time_access * objp)
	{
		if (!xdr_nfstime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_time_access_set(XDR * xdrs,
						      fattr4_time_access_set *
						      objp)
	{
		if (!xdr_settime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_time_backup(XDR * xdrs,
						  fattr4_time_backup * objp)
	{
		if (!xdr_nfstime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_time_create(XDR * xdrs,
						  fattr4_time_create * objp)
	{
		if (!xdr_nfstime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_time_delta(XDR * xdrs,
						 fattr4_time_delta * objp)
	{
		if (!xdr_nfstime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_time_metadata(XDR * xdrs,
						    fattr4_time_metadata *
						    objp)
	{
		if (!xdr_nfstime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_time_modify(XDR * xdrs,
						  fattr4_time_modify * objp)
	{
		if (!xdr_nfstime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_time_modify_set(XDR * xdrs,
						      fattr4_time_modify_set *
						      objp)
	{
		if (!xdr_settime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_suppattr_exclcreat(
					XDR * xdrs,
					fattr4_suppattr_exclcreat * objp)
	{
		if (!xdr_bitmap4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_dir_notif_delay(XDR * xdrs,
						      fattr4_dir_notif_delay *
						      objp)
	{
		if (!xdr_nfstime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_dirent_notif_delay(
					XDR * xdrs,
					fattr4_dirent_notif_delay * objp)
	{
		if (!xdr_nfstime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_fs_layout_types(XDR * xdrs,
						      fattr4_fs_layout_types *
						      objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->fattr4_fs_layout_types_val,
		     (u_int *) &objp->fattr4_fs_layout_types_len, ~0,
		     sizeof(layouttype4), (xdrproc_t) xdr_layouttype4))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_fs_status(XDR * xdrs,
						fattr4_fs_status * objp)
	{
		if (!xdr_fs4_status(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_fs_charset_cap(XDR * xdrs,
						     fattr4_fs_charset_cap *
						     objp)
	{
		if (!xdr_fs_charset_cap4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_layout_alignment(XDR * xdrs,
						       fattr4_layout_alignment *
						       objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_layout_blksize(XDR * xdrs,
						     fattr4_layout_blksize *
						     objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_layout_hint(XDR * xdrs,
						  fattr4_layout_hint * objp)
	{
		if (!xdr_layouthint4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_layout_types(XDR * xdrs,
						   fattr4_layout_types * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->fattr4_layout_types_val,
		     (u_int *) &objp->fattr4_layout_types_len, ~0,
		     sizeof(layouttype4), (xdrproc_t) xdr_layouttype4))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_mdsthreshold(XDR * xdrs,
						   fattr4_mdsthreshold * objp)
	{
		if (!xdr_mdsthreshold4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_retention_get(XDR * xdrs,
						    fattr4_retention_get *
						    objp)
	{
		if (!xdr_retention_get4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_retention_set(XDR * xdrs,
						    fattr4_retention_set *
						    objp)
	{
		if (!xdr_retention_set4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_retentevt_get(XDR * xdrs,
						    fattr4_retentevt_get *
						    objp)
	{
		if (!xdr_retention_get4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_retentevt_set(XDR * xdrs,
						    fattr4_retentevt_set *
						    objp)
	{
		if (!xdr_retention_set4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_retention_hold(XDR * xdrs,
						     fattr4_retention_hold *
						     objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_dacl(XDR * xdrs, fattr4_dacl * objp)
	{
		if (!xdr_nfsacl41(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_sacl(XDR * xdrs, fattr4_sacl * objp)
	{
		if (!xdr_nfsacl41(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_change_policy(XDR * xdrs,
						    fattr4_change_policy *
						    objp)
	{
		if (!xdr_change_policy4(xdrs, objp))
			return false;
		return true;
	}

/*
 * REQUIRED Attributes
 */
/* new to NFSV4.1 */
/*
 * RECOMMENDED Attributes
 */

/* new to NFSV4.1 */

	static inline bool xdr_fattr4(XDR * xdrs, fattr4 * objp)
	{
		if (!xdr_bitmap4(xdrs, &objp->attrmask))
			return false;
		if (!xdr_attrlist4(xdrs, &objp->attr_vals))
			return false;
		return true;
	}

	static inline bool xdr_change_info4(XDR * xdrs, change_info4 * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->atomic))
			return false;
		if (!xdr_changeid4(xdrs, &objp->before))
			return false;
		if (!xdr_changeid4(xdrs, &objp->after))
			return false;
		return true;
	}

	static inline bool xdr_clientaddr4(XDR * xdrs, clientaddr4 * objp)
	{
		if (!xdr_netaddr4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_cb_client4(XDR * xdrs, cb_client4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->cb_program))
			return false;
		if (!xdr_netaddr4(xdrs, &objp->cb_location))
			return false;
		return true;
	}

	static inline bool xdr_nfs_client_id4(XDR * xdrs, nfs_client_id4 * objp)
	{
		if (!xdr_verifier4(xdrs, objp->verifier))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->id.id_val,
		     (u_int *) &objp->id.id_len, NFS4_OPAQUE_LIMIT))
			return false;
		return true;
	}

	static inline bool xdr_client_owner4(XDR * xdrs, client_owner4 * objp)
	{
		if (!xdr_verifier4(xdrs, objp->co_verifier))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->co_ownerid.co_ownerid_val,
		     (u_int *) &objp->co_ownerid.co_ownerid_len,
		     NFS4_OPAQUE_LIMIT))
			return false;
		return true;
	}

	static inline bool xdr_server_owner4(XDR * xdrs, server_owner4 * objp)
	{
		if (!inline_xdr_u_int64_t(xdrs, &objp->so_minor_id))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->so_major_id.so_major_id_val,
		     (u_int *) &objp->so_major_id.so_major_id_len,
		     NFS4_OPAQUE_LIMIT))
			return false;
		return true;
	}

	static inline bool xdr_state_owner4(XDR * xdrs, state_owner4 * objp)
	{
		if (!xdr_clientid4(xdrs, &objp->clientid))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->owner.owner_val,
		     (u_int *) &objp->owner.owner_len, NFS4_OPAQUE_LIMIT))
			return false;
		return true;
	}

	static inline bool xdr_open_owner4(XDR * xdrs, open_owner4 * objp)
	{
		if (!xdr_state_owner4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_lock_owner4(XDR * xdrs, lock_owner4 * objp)
	{
		if (!xdr_state_owner4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_nfs_lock_type4(XDR * xdrs, nfs_lock_type4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

/* Input for computing subkeys */

	static inline bool xdr_ssv_subkey4(XDR * xdrs, ssv_subkey4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

/* Input for computing smt_hmac */

	static inline bool xdr_ssv_mic_plain_tkn4(XDR * xdrs,
						  ssv_mic_plain_tkn4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->smpt_ssv_seq))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->smpt_orig_plain.smpt_orig_plain_val,
		     (u_int *) &objp->smpt_orig_plain.smpt_orig_plain_len, ~0))
			return false;
		return true;
	}

/* SSV GSS PerMsgToken token */

	static inline bool xdr_ssv_mic_tkn4(XDR * xdrs, ssv_mic_tkn4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->smt_ssv_seq))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->smt_hmac.smt_hmac_val,
		     (u_int *) &objp->smt_hmac.smt_hmac_len, ~0))
			return false;
		return true;
	}

/* Input for computing ssct_encr_data and ssct_hmac */

	static inline bool xdr_ssv_seal_plain_tkn4(XDR * xdrs,
						   ssv_seal_plain_tkn4 * objp)
	{
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->sspt_confounder.sspt_confounder_val,
		     (u_int *) &objp->sspt_confounder.sspt_confounder_len, ~0))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->sspt_ssv_seq))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->sspt_orig_plain.sspt_orig_plain_val,
		     (u_int *) &objp->sspt_orig_plain.sspt_orig_plain_len, ~0))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->sspt_pad.sspt_pad_val,
		     (u_int *) &objp->sspt_pad.sspt_pad_len, ~0))
			return false;
		return true;
	}

/* SSV GSS SealedMessage token */

	static inline bool xdr_ssv_seal_cipher_tkn4(XDR * xdrs,
						    ssv_seal_cipher_tkn4 *
						    objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->ssct_ssv_seq))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->ssct_iv.ssct_iv_val,
		     (u_int *) &objp->ssct_iv.ssct_iv_len, ~0))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->ssct_encr_data.ssct_encr_data_val,
		     (u_int *) &objp->ssct_encr_data.ssct_encr_data_len, ~0))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->ssct_hmac.ssct_hmac_val,
		     (u_int *) &objp->ssct_hmac.ssct_hmac_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_fs_locations_server4(XDR * xdrs,
						    fs_locations_server4 *
						    objp)
	{
		if (!xdr_int32_t(xdrs, &objp->fls_currency))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->fls_info.fls_info_val,
		     (u_int *) &objp->fls_info.fls_info_len, ~0))
			return false;
		if (!xdr_utf8str_cis(xdrs, &objp->fls_server))
			return false;
		return true;
	}

	static inline bool xdr_fs_locations_item4(XDR * xdrs,
						  fs_locations_item4 * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->fli_entries.fli_entries_val,
		     (u_int *) &objp->fli_entries.fli_entries_len, ~0,
		     sizeof(fs_locations_server4),
		     (xdrproc_t) xdr_fs_locations_server4))
			return false;
		if (!xdr_pathname4(xdrs, &objp->fli_rootpath))
			return false;
		return true;
	}

	static inline bool xdr_fs_locations_info4(XDR * xdrs,
						  fs_locations_info4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->fli_flags))
			return false;
		if (!xdr_int32_t(xdrs, &objp->fli_valid_for))
			return false;
		if (!xdr_pathname4(xdrs, &objp->fli_fs_root))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->fli_items.fli_items_val,
		     (u_int *) &objp->fli_items.fli_items_len, ~0,
		     sizeof(fs_locations_item4),
		     (xdrproc_t) xdr_fs_locations_item4))
			return false;
		return true;
	}

	static inline bool xdr_fattr4_fs_locations_info(XDR * xdrs,
							fattr4_fs_locations_info
							* objp)
	{
		if (!xdr_fs_locations_info4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_nfl_util4(XDR * xdrs, nfl_util4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_filelayout_hint_care4(XDR * xdrs,
						     filelayout_hint_care4 *
						     objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

/* Encoded in the loh_body field of data type layouthint4: */

	static inline bool xdr_nfsv4_1_file_layouthint4(XDR * xdrs,
							nfsv4_1_file_layouthint4
							* objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->nflh_care))
			return false;
		if (!xdr_nfl_util4(xdrs, &objp->nflh_util))
			return false;
		if (!xdr_count4(xdrs, &objp->nflh_stripe_count))
			return false;
		return true;
	}

	static inline bool xdr_multipath_list4(XDR * xdrs,
					       multipath_list4 * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->multipath_list4_val,
		     (u_int *) &objp->multipath_list4_len, ~0,
		     sizeof(netaddr4), (xdrproc_t) xdr_netaddr4))
			return false;
		return true;
	}

/*
 * Encoded in the da_addr_body field of
 * data type device_addr4:
 */

	static inline bool xdr_nfsv4_1_file_layout_ds_addr4(
					XDR * xdrs,
					nfsv4_1_file_layout_ds_addr4 * objp)
	{
		if (!xdr_array
		    (xdrs,
		     (char **)&objp->nflda_stripe_indices.
		     nflda_stripe_indices_val,
		     (u_int *) &objp->nflda_stripe_indices.
		     nflda_stripe_indices_len, ~0, sizeof(uint32_t),
		     (xdrproc_t) xdr_uint32_t))
			return false;
		if (!xdr_array
		    (xdrs,
		     (char **)&objp->nflda_multipath_ds_list.
		     nflda_multipath_ds_list_val,
		     (u_int *) &objp->nflda_multipath_ds_list.
		     nflda_multipath_ds_list_len, ~0, sizeof(multipath_list4),
		     (xdrproc_t) xdr_multipath_list4))
			return false;
		return true;
	}

/*
 * Encoded in the loc_body field of
 * data type layout_content4:
 */

	static inline bool xdr_nfsv4_1_file_layout4(XDR * xdrs,
						    nfsv4_1_file_layout4 *
						    objp)
	{
		if (!xdr_deviceid4(xdrs, objp->nfl_deviceid))
			return false;
		if (!xdr_nfl_util4(xdrs, &objp->nfl_util))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->nfl_first_stripe_index))
			return false;
		if (!xdr_offset4(xdrs, &objp->nfl_pattern_offset))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->nfl_fh_list.nfl_fh_list_val,
		     (u_int *) &objp->nfl_fh_list.nfl_fh_list_len, ~0,
		     sizeof(nfs_fh4), (xdrproc_t) xdr_nfs_fh4))
			return false;
		return true;
	}

/*
 * Encoded in the lou_body field of data type layoutupdate4:
 *      Nothing. lou_body is a zero length array of bytes.
 */

/*
 * Encoded in the lrf_body field of
 * data type layoutreturn_file4:
 *      Nothing. lrf_body is a zero length array of bytes.
 */

	static inline bool xdr_ACCESS4args(XDR * xdrs, ACCESS4args * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->access))
			return false;
		return true;
	}

	static inline bool xdr_ACCESS4resok(XDR * xdrs, ACCESS4resok * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->supported))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->access))
			return false;
		return true;
	}

	static inline bool xdr_ACCESS4res(XDR * xdrs, ACCESS4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_ACCESS4resok(xdrs, &objp->ACCESS4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_CLOSE4args(XDR * xdrs, CLOSE4args * objp)
	{
		if (!xdr_seqid4(xdrs, &objp->seqid))
			return false;
		if (!xdr_stateid4(xdrs, &objp->open_stateid))
			return false;
		return true;
	}

	static inline bool xdr_CLOSE4res(XDR * xdrs, CLOSE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_stateid4
			    (xdrs, &objp->CLOSE4res_u.open_stateid))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_COMMIT4args(XDR * xdrs, COMMIT4args * objp)
	{
		if (!xdr_offset4(xdrs, &objp->offset))
			return false;
		if (!xdr_count4(xdrs, &objp->count))
			return false;
		return true;
	}

	static inline bool xdr_COMMIT4resok(XDR * xdrs, COMMIT4resok * objp)
	{
		if (!xdr_verifier4(xdrs, objp->writeverf))
			return false;
		return true;
	}

	static inline bool xdr_COMMIT4res(XDR * xdrs, COMMIT4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_COMMIT4resok(xdrs, &objp->COMMIT4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_createtype4(XDR * xdrs, createtype4 * objp)
	{
		if (!xdr_nfs_ftype4(xdrs, &objp->type))
			return false;
		switch (objp->type) {
		case NF4LNK:
			if (!xdr_linktext4(xdrs, &objp->createtype4_u.linkdata))
				return false;
			break;
		case NF4BLK:
		case NF4CHR:
			if (!xdr_specdata4(xdrs, &objp->createtype4_u.devdata))
				return false;
			break;
		case NF4SOCK:
		case NF4FIFO:
		case NF4DIR:
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_CREATE4args(XDR * xdrs, CREATE4args * objp)
	{
		if (!xdr_createtype4(xdrs, &objp->objtype))
			return false;
		if (!xdr_component4(xdrs, &objp->objname))
			return false;
		if (!xdr_fattr4(xdrs, &objp->createattrs))
			return false;
		return true;
	}

	static inline bool xdr_CREATE4resok(XDR * xdrs, CREATE4resok * objp)
	{
		if (!xdr_change_info4(xdrs, &objp->cinfo))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->attrset))
			return false;
		return true;
	}

	static inline bool xdr_CREATE4res(XDR * xdrs, CREATE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_CREATE4resok(xdrs, &objp->CREATE4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_DELEGPURGE4args(XDR * xdrs,
					       DELEGPURGE4args * objp)
	{
		if (!xdr_clientid4(xdrs, &objp->clientid))
			return false;
		return true;
	}

	static inline bool xdr_DELEGPURGE4res(XDR * xdrs, DELEGPURGE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_DELEGRETURN4args(XDR * xdrs,
						DELEGRETURN4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->deleg_stateid))
			return false;
		return true;
	}

	static inline bool xdr_DELEGRETURN4res(XDR * xdrs,
					       DELEGRETURN4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_GETATTR4args(XDR * xdrs, GETATTR4args * objp)
	{
		if (!xdr_bitmap4(xdrs, &objp->attr_request))
			return false;
		return true;
	}

	static inline bool xdr_GETATTR4resok(XDR * xdrs, GETATTR4resok * objp)
	{
		if (!xdr_fattr4(xdrs, &objp->obj_attributes))
			return false;
		return true;
	}

	static inline bool xdr_GETATTR4res(XDR * xdrs, GETATTR4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_GETATTR4resok
			    (xdrs, &objp->GETATTR4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_GETFH4resok(XDR * xdrs, GETFH4resok * objp)
	{
		if (!xdr_nfs_fh4(xdrs, &objp->object))
			return false;
		return true;
	}

	static inline bool xdr_GETFH4res(XDR * xdrs, GETFH4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_GETFH4resok(xdrs, &objp->GETFH4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_LINK4args(XDR * xdrs, LINK4args * objp)
	{
		if (!xdr_component4(xdrs, &objp->newname))
			return false;
		return true;
	}

	static inline bool xdr_LINK4resok(XDR * xdrs, LINK4resok * objp)
	{
		if (!xdr_change_info4(xdrs, &objp->cinfo))
			return false;
		return true;
	}

	static inline bool xdr_LINK4res(XDR * xdrs, LINK4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_LINK4resok(xdrs, &objp->LINK4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_open_to_lock_owner4(XDR * xdrs,
						   open_to_lock_owner4 * objp)
	{
		if (!xdr_seqid4(xdrs, &objp->open_seqid))
			return false;
		if (!xdr_stateid4(xdrs, &objp->open_stateid))
			return false;
		if (!xdr_seqid4(xdrs, &objp->lock_seqid))
			return false;
		if (!xdr_lock_owner4(xdrs, &objp->lock_owner))
			return false;
		return true;
	}

	static inline bool xdr_exist_lock_owner4(XDR * xdrs,
						 exist_lock_owner4 * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->lock_stateid))
			return false;
		if (!xdr_seqid4(xdrs, &objp->lock_seqid))
			return false;
		return true;
	}

	static inline bool xdr_locker4(XDR * xdrs, locker4 * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->new_lock_owner))
			return false;
		switch (objp->new_lock_owner) {
		case true:
			if (!xdr_open_to_lock_owner4
			    (xdrs, &objp->locker4_u.open_owner))
				return false;
			break;
		case false:
			if (!xdr_exist_lock_owner4
			    (xdrs, &objp->locker4_u.lock_owner))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_LOCK4args(XDR * xdrs, LOCK4args * objp)
	{
		if (!xdr_nfs_lock_type4(xdrs, &objp->locktype))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->reclaim))
			return false;
		if (!xdr_offset4(xdrs, &objp->offset))
			return false;
		if (!xdr_length4(xdrs, &objp->length))
			return false;
		if (!xdr_locker4(xdrs, &objp->locker))
			return false;
		return true;
	}

	static inline bool xdr_LOCK4denied(XDR * xdrs, LOCK4denied * objp)
	{
		if (!xdr_offset4(xdrs, &objp->offset))
			return false;
		if (!xdr_length4(xdrs, &objp->length))
			return false;
		if (!xdr_nfs_lock_type4(xdrs, &objp->locktype))
			return false;
		if (!xdr_lock_owner4(xdrs, &objp->owner))
			return false;
		return true;
	}

	static inline bool xdr_LOCK4resok(XDR * xdrs, LOCK4resok * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->lock_stateid))
			return false;
		return true;
	}

	static inline bool xdr_LOCK4res(XDR * xdrs, LOCK4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_LOCK4resok(xdrs, &objp->LOCK4res_u.resok4))
				return false;
			break;
		case NFS4ERR_DENIED:
			if (!xdr_LOCK4denied(xdrs, &objp->LOCK4res_u.denied))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_LOCKT4args(XDR * xdrs, LOCKT4args * objp)
	{
		if (!xdr_nfs_lock_type4(xdrs, &objp->locktype))
			return false;
		if (!xdr_offset4(xdrs, &objp->offset))
			return false;
		if (!xdr_length4(xdrs, &objp->length))
			return false;
		if (!xdr_lock_owner4(xdrs, &objp->owner))
			return false;
		return true;
	}

	static inline bool xdr_LOCKT4res(XDR * xdrs, LOCKT4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4ERR_DENIED:
			if (!xdr_LOCK4denied(xdrs, &objp->LOCKT4res_u.denied))
				return false;
			break;
		case NFS4_OK:
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_LOCKU4args(XDR * xdrs, LOCKU4args * objp)
	{
		if (!xdr_nfs_lock_type4(xdrs, &objp->locktype))
			return false;
		if (!xdr_seqid4(xdrs, &objp->seqid))
			return false;
		if (!xdr_stateid4(xdrs, &objp->lock_stateid))
			return false;
		if (!xdr_offset4(xdrs, &objp->offset))
			return false;
		if (!xdr_length4(xdrs, &objp->length))
			return false;
		return true;
	}

	static inline bool xdr_LOCKU4res(XDR * xdrs, LOCKU4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_stateid4
			    (xdrs, &objp->LOCKU4res_u.lock_stateid))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_LOOKUP4args(XDR * xdrs, LOOKUP4args * objp)
	{
		if (!xdr_component4(xdrs, &objp->objname))
			return false;
		return true;
	}

	static inline bool xdr_LOOKUP4res(XDR * xdrs, LOOKUP4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_LOOKUPP4res(XDR * xdrs, LOOKUPP4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_NVERIFY4args(XDR * xdrs, NVERIFY4args * objp)
	{
		if (!xdr_fattr4(xdrs, &objp->obj_attributes))
			return false;
		return true;
	}

	static inline bool xdr_NVERIFY4res(XDR * xdrs, NVERIFY4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_createmode4(XDR * xdrs, createmode4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_creatverfattr(XDR * xdrs, creatverfattr * objp)
	{
		if (!xdr_verifier4(xdrs, objp->cva_verf))
			return false;
		if (!xdr_fattr4(xdrs, &objp->cva_attrs))
			return false;
		return true;
	}

	static inline bool xdr_createhow4(XDR * xdrs, createhow4 * objp)
	{
		if (!xdr_createmode4(xdrs, &objp->mode))
			return false;
		switch (objp->mode) {
		case UNCHECKED4:
		case GUARDED4:
			if (!xdr_fattr4(xdrs, &objp->createhow4_u.createattrs))
				return false;
			break;
		case EXCLUSIVE4:
			if (!xdr_verifier4(xdrs, objp->createhow4_u.createverf))
				return false;
			break;
		case EXCLUSIVE4_1:
			if (!xdr_creatverfattr
			    (xdrs, &objp->createhow4_u.ch_createboth))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_opentype4(XDR * xdrs, opentype4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_openflag4(XDR * xdrs, openflag4 * objp)
	{
		if (!xdr_opentype4(xdrs, &objp->opentype))
			return false;
		switch (objp->opentype) {
		case OPEN4_CREATE:
			if (!xdr_createhow4(xdrs, &objp->openflag4_u.how))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_limit_by4(XDR * xdrs, limit_by4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_nfs_modified_limit4(XDR * xdrs,
						   nfs_modified_limit4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->num_blocks))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->bytes_per_block))
			return false;
		return true;
	}

	static inline bool xdr_nfs_space_limit4(XDR * xdrs,
						nfs_space_limit4 * objp)
	{
		if (!xdr_limit_by4(xdrs, &objp->limitby))
			return false;
		switch (objp->limitby) {
		case NFS_LIMIT_SIZE:
			if (!inline_xdr_u_int64_t
			    (xdrs, &objp->nfs_space_limit4_u.filesize))
				return false;
			break;
		case NFS_LIMIT_BLOCKS:
			if (!xdr_nfs_modified_limit4
			    (xdrs, &objp->nfs_space_limit4_u.mod_blocks))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_open_delegation_type4(XDR * xdrs,
						     open_delegation_type4 *
						     objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_open_claim_type4(XDR * xdrs,
						open_claim_type4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_open_claim_delegate_cur4(XDR * xdrs,
							open_claim_delegate_cur4
							* objp)
	{
		if (!xdr_stateid4(xdrs, &objp->delegate_stateid))
			return false;
		if (!xdr_component4(xdrs, &objp->file))
			return false;
		return true;
	}

	static inline bool xdr_open_claim4(XDR * xdrs, open_claim4 * objp)
	{
		if (!xdr_open_claim_type4(xdrs, &objp->claim))
			return false;
		switch (objp->claim) {
		case CLAIM_NULL:
			if (!xdr_component4(xdrs, &objp->open_claim4_u.file))
				return false;
			break;
		case CLAIM_PREVIOUS:
			if (!xdr_open_delegation_type4
			    (xdrs, &objp->open_claim4_u.delegate_type))
				return false;
			break;
		case CLAIM_DELEGATE_CUR:
			if (!xdr_open_claim_delegate_cur4
			    (xdrs, &objp->open_claim4_u.delegate_cur_info))
				return false;
			break;
		case CLAIM_DELEGATE_PREV:
			if (!xdr_component4
			    (xdrs, &objp->open_claim4_u.file_delegate_prev))
				return false;
			break;
		case CLAIM_FH:
			break;
		case CLAIM_DELEG_PREV_FH:
			break;
		case CLAIM_DELEG_CUR_FH:
			if (!xdr_stateid4
			    (xdrs, &objp->open_claim4_u.oc_delegate_stateid))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_OPEN4args(XDR * xdrs, OPEN4args * objp)
	{
		if (!xdr_seqid4(xdrs, &objp->seqid))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->share_access))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->share_deny))
			return false;
		if (!xdr_open_owner4(xdrs, &objp->owner))
			return false;
		if (!xdr_openflag4(xdrs, &objp->openhow))
			return false;
		if (!xdr_open_claim4(xdrs, &objp->claim))
			return false;
		return true;
	}

	static inline bool xdr_open_read_delegation4(XDR * xdrs,
						     open_read_delegation4 *
						     objp)
	{
		if (!xdr_stateid4(xdrs, &objp->stateid))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->recall))
			return false;
		if (!xdr_nfsace4(xdrs, &objp->permissions))
			return false;
		return true;
	}

	static inline bool xdr_open_write_delegation4(XDR * xdrs,
						      open_write_delegation4 *
						      objp)
	{
		if (!xdr_stateid4(xdrs, &objp->stateid))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->recall))
			return false;
		if (!xdr_nfs_space_limit4(xdrs, &objp->space_limit))
			return false;
		if (!xdr_nfsace4(xdrs, &objp->permissions))
			return false;
		return true;
	}

	static inline bool xdr_why_no_delegation4(XDR * xdrs,
						  why_no_delegation4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_open_none_delegation4(XDR * xdrs,
						     open_none_delegation4 *
						     objp)
	{
		if (!xdr_why_no_delegation4(xdrs, &objp->ond_why))
			return false;
		switch (objp->ond_why) {
		case WND4_CONTENTION:
			if (!inline_xdr_bool
			    (xdrs,
			     &objp->open_none_delegation4_u.
			     ond_server_will_push_deleg))
				return false;
			break;
		case WND4_RESOURCE:
			if (!inline_xdr_bool
			    (xdrs,
			     &objp->open_none_delegation4_u.
			     ond_server_will_signal_avail))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_open_delegation4(XDR * xdrs,
						open_delegation4 * objp)
	{
		if (!xdr_open_delegation_type4(xdrs, &objp->delegation_type))
			return false;
		switch (objp->delegation_type) {
		case OPEN_DELEGATE_NONE:
			break;
		case OPEN_DELEGATE_READ:
			if (!xdr_open_read_delegation4
			    (xdrs, &objp->open_delegation4_u.read))
				return false;
			break;
		case OPEN_DELEGATE_WRITE:
			if (!xdr_open_write_delegation4
			    (xdrs, &objp->open_delegation4_u.write))
				return false;
			break;
		case OPEN_DELEGATE_NONE_EXT:
			if (!xdr_open_none_delegation4
			    (xdrs, &objp->open_delegation4_u.od_whynone))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_OPEN4resok(XDR * xdrs, OPEN4resok * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->stateid))
			return false;
		if (!xdr_change_info4(xdrs, &objp->cinfo))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->rflags))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->attrset))
			return false;
		if (!xdr_open_delegation4(xdrs, &objp->delegation))
			return false;
		return true;
	}

	static inline bool xdr_OPEN4res(XDR * xdrs, OPEN4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_OPEN4resok(xdrs, &objp->OPEN4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_OPENATTR4args(XDR * xdrs, OPENATTR4args * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->createdir))
			return false;
		return true;
	}

	static inline bool xdr_OPENATTR4res(XDR * xdrs, OPENATTR4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_OPEN_CONFIRM4args(XDR * xdrs,
						 OPEN_CONFIRM4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->open_stateid))
			return false;
		if (!xdr_seqid4(xdrs, &objp->seqid))
			return false;
		return true;
	}

	static inline bool xdr_OPEN_CONFIRM4resok(XDR * xdrs,
						  OPEN_CONFIRM4resok * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->open_stateid))
			return false;
		return true;
	}

	static inline bool xdr_OPEN_CONFIRM4res(XDR * xdrs,
						OPEN_CONFIRM4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_OPEN_CONFIRM4resok
			    (xdrs, &objp->OPEN_CONFIRM4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_OPEN_DOWNGRADE4args(XDR * xdrs,
						   OPEN_DOWNGRADE4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->open_stateid))
			return false;
		if (!xdr_seqid4(xdrs, &objp->seqid))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->share_access))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->share_deny))
			return false;
		return true;
	}

	static inline bool xdr_OPEN_DOWNGRADE4resok(XDR * xdrs,
						    OPEN_DOWNGRADE4resok *
						    objp)
	{
		if (!xdr_stateid4(xdrs, &objp->open_stateid))
			return false;
		return true;
	}

	static inline bool xdr_OPEN_DOWNGRADE4res(XDR * xdrs,
						  OPEN_DOWNGRADE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_OPEN_DOWNGRADE4resok
			    (xdrs, &objp->OPEN_DOWNGRADE4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_PUTFH4args(XDR * xdrs, PUTFH4args * objp)
	{
		if (!xdr_nfs_fh4(xdrs, &objp->object))
			return false;
		return true;
	}

	static inline bool xdr_PUTFH4res(XDR * xdrs, PUTFH4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_PUTPUBFH4res(XDR * xdrs, PUTPUBFH4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_PUTROOTFH4res(XDR * xdrs, PUTROOTFH4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_READ4args(XDR * xdrs, READ4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->stateid))
			return false;
		if (!xdr_offset4(xdrs, &objp->offset))
			return false;
		if (!xdr_count4(xdrs, &objp->count))
			return false;
		return true;
	}

	static inline bool xdr_READ4resok(XDR * xdrs, READ4resok * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->eof))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->data.data_val,
		     (u_int *) &objp->data.data_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_READ4res(XDR * xdrs, READ4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_READ4resok(xdrs, &objp->READ4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_READDIR4args(XDR * xdrs, READDIR4args * objp)
	{
		if (!xdr_nfs_cookie4(xdrs, &objp->cookie))
			return false;
		if (!xdr_verifier4(xdrs, objp->cookieverf))
			return false;
		if (!xdr_count4(xdrs, &objp->dircount))
			return false;
		if (!xdr_count4(xdrs, &objp->maxcount))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->attr_request))
			return false;
		return true;
	}

	static inline bool xdr_entry4(XDR * xdrs, entry4 * objp)
	{
		if (!xdr_nfs_cookie4(xdrs, &objp->cookie))
			return false;
		if (!xdr_component4(xdrs, &objp->name))
			return false;
		if (!xdr_fattr4(xdrs, &objp->attrs))
			return false;
		if (!xdr_pointer
		    (xdrs, (char **)&objp->nextentry, sizeof(entry4),
		     (xdrproc_t) xdr_entry4))
			return false;
		return true;
	}

	static inline bool xdr_dirlist4(XDR * xdrs, dirlist4 * objp)
	{
		if (!xdr_pointer
		    (xdrs, (char **)&objp->entries, sizeof(entry4),
		     (xdrproc_t) xdr_entry4))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->eof))
			return false;
		return true;
	}

	static inline bool xdr_READDIR4resok(XDR * xdrs, READDIR4resok * objp)
	{
		if (!xdr_verifier4(xdrs, objp->cookieverf))
			return false;
		if (!xdr_dirlist4(xdrs, &objp->reply))
			return false;
		return true;
	}

	static inline bool xdr_READDIR4res(XDR * xdrs, READDIR4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_READDIR4resok
			    (xdrs, &objp->READDIR4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_READLINK4resok(XDR * xdrs, READLINK4resok * objp)
	{
		if (!xdr_linktext4(xdrs, &objp->link))
			return false;
		return true;
	}

	static inline bool xdr_READLINK4res(XDR * xdrs, READLINK4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_READLINK4resok
			    (xdrs, &objp->READLINK4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_REMOVE4args(XDR * xdrs, REMOVE4args * objp)
	{
		if (!xdr_component4(xdrs, &objp->target))
			return false;
		return true;
	}

	static inline bool xdr_REMOVE4resok(XDR * xdrs, REMOVE4resok * objp)
	{
		if (!xdr_change_info4(xdrs, &objp->cinfo))
			return false;
		return true;
	}

	static inline bool xdr_REMOVE4res(XDR * xdrs, REMOVE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_REMOVE4resok(xdrs, &objp->REMOVE4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_RENAME4args(XDR * xdrs, RENAME4args * objp)
	{
		if (!xdr_component4(xdrs, &objp->oldname))
			return false;
		if (!xdr_component4(xdrs, &objp->newname))
			return false;
		return true;
	}

	static inline bool xdr_RENAME4resok(XDR * xdrs, RENAME4resok * objp)
	{
		if (!xdr_change_info4(xdrs, &objp->source_cinfo))
			return false;
		if (!xdr_change_info4(xdrs, &objp->target_cinfo))
			return false;
		return true;
	}

	static inline bool xdr_RENAME4res(XDR * xdrs, RENAME4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_RENAME4resok(xdrs, &objp->RENAME4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_RENEW4args(XDR * xdrs, RENEW4args * objp)
	{
		if (!xdr_clientid4(xdrs, &objp->clientid))
			return false;
		return true;
	}

	static inline bool xdr_RENEW4res(XDR * xdrs, RENEW4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_RESTOREFH4res(XDR * xdrs, RESTOREFH4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_SAVEFH4res(XDR * xdrs, SAVEFH4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_SECINFO4args(XDR * xdrs, SECINFO4args * objp)
	{
		if (!xdr_component4(xdrs, &objp->name))
			return false;
		return true;
	}

	static inline bool xdr_rpc_gss_svc_t(XDR * xdrs, rpc_gss_svc_t *objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_rpcsec_gss_info(XDR * xdrs,
					       rpcsec_gss_info * objp)
	{
		if (!xdr_sec_oid4(xdrs, &objp->oid))
			return false;
		if (!xdr_qop4(xdrs, &objp->qop))
			return false;
		if (!xdr_rpc_gss_svc_t(xdrs, &objp->service))
			return false;
		return true;
	}

	static inline bool xdr_secinfo4(XDR * xdrs, secinfo4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->flavor))
			return false;
		switch (objp->flavor) {
		case RPCSEC_GSS:
			if (!xdr_rpcsec_gss_info
			    (xdrs, &objp->secinfo4_u.flavor_info))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_SECINFO4resok(XDR * xdrs, SECINFO4resok * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->SECINFO4resok_val,
		     (u_int *) &objp->SECINFO4resok_len, ~0, sizeof(secinfo4),
		     (xdrproc_t) xdr_secinfo4))
			return false;
		return true;
	}

	static inline bool xdr_SECINFO4res(XDR * xdrs, SECINFO4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_SECINFO4resok
			    (xdrs, &objp->SECINFO4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_SETATTR4args(XDR * xdrs, SETATTR4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->stateid))
			return false;
		if (!xdr_fattr4(xdrs, &objp->obj_attributes))
			return false;
		return true;
	}

	static inline bool xdr_SETATTR4res(XDR * xdrs, SETATTR4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->attrsset))
			return false;
		return true;
	}

	static inline bool xdr_SETCLIENTID4args(XDR * xdrs,
						SETCLIENTID4args * objp)
	{
		if (!xdr_nfs_client_id4(xdrs, &objp->client))
			return false;
		if (!xdr_cb_client4(xdrs, &objp->callback))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->callback_ident))
			return false;
		return true;
	}

	static inline bool xdr_SETCLIENTID4resok(XDR * xdrs,
						 SETCLIENTID4resok * objp)
	{
		if (!xdr_clientid4(xdrs, &objp->clientid))
			return false;
		if (!xdr_verifier4(xdrs, objp->setclientid_confirm))
			return false;
		return true;
	}

	static inline bool xdr_SETCLIENTID4res(XDR * xdrs,
					       SETCLIENTID4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_SETCLIENTID4resok
			    (xdrs, &objp->SETCLIENTID4res_u.resok4))
				return false;
			break;
		case NFS4ERR_CLID_INUSE:
			if (!xdr_clientaddr4
			    (xdrs, &objp->SETCLIENTID4res_u.client_using))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_SETCLIENTID_CONFIRM4args(XDR * xdrs,
							SETCLIENTID_CONFIRM4args
							* objp)
	{
		if (!xdr_clientid4(xdrs, &objp->clientid))
			return false;
		if (!xdr_verifier4(xdrs, objp->setclientid_confirm))
			return false;
		return true;
	}

	static inline bool xdr_SETCLIENTID_CONFIRM4res(XDR * xdrs,
						       SETCLIENTID_CONFIRM4res *
						       objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_VERIFY4args(XDR * xdrs, VERIFY4args * objp)
	{
		if (!xdr_fattr4(xdrs, &objp->obj_attributes))
			return false;
		return true;
	}

	static inline bool xdr_VERIFY4res(XDR * xdrs, VERIFY4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_stable_how4(XDR * xdrs, stable_how4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_WRITE4args(XDR * xdrs, WRITE4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->stateid))
			return false;
		if (!xdr_offset4(xdrs, &objp->offset))
			return false;
		if (!xdr_stable_how4(xdrs, &objp->stable))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->data.data_val,
		     (u_int *) &objp->data.data_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_WRITE4resok(XDR * xdrs, WRITE4resok * objp)
	{
		if (!xdr_count4(xdrs, &objp->count))
			return false;
		if (!xdr_stable_how4(xdrs, &objp->committed))
			return false;
		if (!xdr_verifier4(xdrs, objp->writeverf))
			return false;
		return true;
	}

	static inline bool xdr_WRITE4res(XDR * xdrs, WRITE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_WRITE4resok(xdrs, &objp->WRITE4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_RELEASE_LOCKOWNER4args(XDR * xdrs,
						      RELEASE_LOCKOWNER4args *
						      objp)
	{
		if (!xdr_lock_owner4(xdrs, &objp->lock_owner))
			return false;
		return true;
	}

	static inline bool xdr_RELEASE_LOCKOWNER4res(XDR * xdrs,
						     RELEASE_LOCKOWNER4res *
						     objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_ILLEGAL4res(XDR * xdrs, ILLEGAL4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_gsshandle4_t(XDR * xdrs, gsshandle4_t *objp)
	{
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->gsshandle4_t_val,
		     (u_int *) &objp->gsshandle4_t_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_gss_cb_handles4(XDR * xdrs,
					       gss_cb_handles4 * objp)
	{
		if (!xdr_rpc_gss_svc_t(xdrs, &objp->gcbp_service))
			return false;
		if (!xdr_gsshandle4_t(xdrs, &objp->gcbp_handle_from_server))
			return false;
		if (!xdr_gsshandle4_t(xdrs, &objp->gcbp_handle_from_client))
			return false;
		return true;
	}

	static inline bool xdr_callback_sec_parms4(XDR * xdrs,
						   callback_sec_parms4 * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->cb_secflavor))
			return false;
		switch (objp->cb_secflavor) {
		case AUTH_NONE:
			break;
		case AUTH_SYS:
			if (!xdr_authunix_parms
			    (xdrs, &objp->callback_sec_parms4_u.cbsp_sys_cred))
				return false;
			break;
		case RPCSEC_GSS:
			if (!xdr_gss_cb_handles4
			    (xdrs,
			     &objp->callback_sec_parms4_u.cbsp_gss_handles))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_BACKCHANNEL_CTL4args(XDR * xdrs,
						    BACKCHANNEL_CTL4args *
						    objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->bca_cb_program))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->bca_sec_parms.bca_sec_parms_val,
		     (u_int *) &objp->bca_sec_parms.bca_sec_parms_len, ~0,
		     sizeof(callback_sec_parms4),
		     (xdrproc_t) xdr_callback_sec_parms4))
			return false;
		return true;
	}

	static inline bool xdr_BACKCHANNEL_CTL4res(XDR * xdrs,
						   BACKCHANNEL_CTL4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->bcr_status))
			return false;
		return true;
	}

	static inline bool xdr_channel_dir_from_client4(
						XDR * xdrs,
						channel_dir_from_client4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_BIND_CONN_TO_SESSION4args(
					XDR * xdrs,
					BIND_CONN_TO_SESSION4args * objp)
	{
		if (!xdr_sessionid4(xdrs, objp->bctsa_sessid))
			return false;
		if (!xdr_channel_dir_from_client4(xdrs, &objp->bctsa_dir))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->bctsa_use_conn_in_rdma_mode))
			return false;
		return true;
	}

	static inline bool xdr_channel_dir_from_server4(XDR * xdrs,
							channel_dir_from_server4
							* objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_BIND_CONN_TO_SESSION4resok(
					XDR * xdrs,
					BIND_CONN_TO_SESSION4resok * objp)
	{
		if (!xdr_sessionid4(xdrs, objp->bctsr_sessid))
			return false;
		if (!xdr_channel_dir_from_server4(xdrs, &objp->bctsr_dir))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->bctsr_use_conn_in_rdma_mode))
			return false;
		return true;
	}

	static inline bool xdr_BIND_CONN_TO_SESSION4res(XDR * xdrs,
							BIND_CONN_TO_SESSION4res
							* objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->bctsr_status))
			return false;
		switch (objp->bctsr_status) {
		case NFS4_OK:
			if (!xdr_BIND_CONN_TO_SESSION4resok
			    (xdrs,
			     &objp->BIND_CONN_TO_SESSION4res_u.bctsr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_state_protect_ops4(XDR * xdrs,
						  state_protect_ops4 * objp)
	{
		if (!xdr_bitmap4(xdrs, &objp->spo_must_enforce))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->spo_must_allow))
			return false;
		return true;
	}

	static inline bool xdr_ssv_sp_parms4(XDR * xdrs, ssv_sp_parms4 * objp)
	{
		if (!xdr_state_protect_ops4(xdrs, &objp->ssp_ops))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->ssp_hash_algs.ssp_hash_algs_val,
		     (u_int *) &objp->ssp_hash_algs.ssp_hash_algs_len, ~0,
		     sizeof(sec_oid4), (xdrproc_t) xdr_sec_oid4))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->ssp_encr_algs.ssp_encr_algs_val,
		     (u_int *) &objp->ssp_encr_algs.ssp_encr_algs_len, ~0,
		     sizeof(sec_oid4), (xdrproc_t) xdr_sec_oid4))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->ssp_window))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->ssp_num_gss_handles))
			return false;
		return true;
	}

	static inline bool xdr_state_protect_how4(XDR * xdrs,
						  state_protect_how4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_state_protect4_a(XDR * xdrs,
						state_protect4_a * objp)
	{
		if (!xdr_state_protect_how4(xdrs, &objp->spa_how))
			return false;
		switch (objp->spa_how) {
		case SP4_NONE:
			break;
		case SP4_MACH_CRED:
			if (!xdr_state_protect_ops4
			    (xdrs, &objp->state_protect4_a_u.spa_mach_ops))
				return false;
			break;
		case SP4_SSV:
			if (!xdr_ssv_sp_parms4
			    (xdrs, &objp->state_protect4_a_u.spa_ssv_parms))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_EXCHANGE_ID4args(XDR * xdrs,
						EXCHANGE_ID4args * objp)
	{
		if (!xdr_client_owner4(xdrs, &objp->eia_clientowner))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->eia_flags))
			return false;
		if (!xdr_state_protect4_a(xdrs, &objp->eia_state_protect))
			return false;
		if (!xdr_array
		    (xdrs,
		     (char **)&objp->eia_client_impl_id.eia_client_impl_id_val,
		     (u_int *) &objp->eia_client_impl_id.
		     eia_client_impl_id_len, 1, sizeof(nfs_impl_id4),
		     (xdrproc_t) xdr_nfs_impl_id4))
			return false;
		return true;
	}

	static inline bool xdr_ssv_prot_info4(XDR * xdrs, ssv_prot_info4 * objp)
	{
		if (!xdr_state_protect_ops4(xdrs, &objp->spi_ops))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->spi_hash_alg))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->spi_encr_alg))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->spi_ssv_len))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->spi_window))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->spi_handles.spi_handles_val,
		     (u_int *) &objp->spi_handles.spi_handles_len, ~0,
		     sizeof(gsshandle4_t), (xdrproc_t) xdr_gsshandle4_t))
			return false;
		return true;
	}

	static inline bool xdr_state_protect4_r(XDR * xdrs,
						state_protect4_r * objp)
	{
		if (!xdr_state_protect_how4(xdrs, &objp->spr_how))
			return false;
		switch (objp->spr_how) {
		case SP4_NONE:
			break;
		case SP4_MACH_CRED:
			if (!xdr_state_protect_ops4
			    (xdrs, &objp->state_protect4_r_u.spr_mach_ops))
				return false;
			break;
		case SP4_SSV:
			if (!xdr_ssv_prot_info4
			    (xdrs, &objp->state_protect4_r_u.spr_ssv_info))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_EXCHANGE_ID4resok(XDR * xdrs,
						 EXCHANGE_ID4resok * objp)
	{
		if (!xdr_clientid4(xdrs, &objp->eir_clientid))
			return false;
		if (!xdr_sequenceid4(xdrs, &objp->eir_sequenceid))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->eir_flags))
			return false;
		if (!xdr_state_protect4_r(xdrs, &objp->eir_state_protect))
			return false;
		if (!xdr_server_owner4(xdrs, &objp->eir_server_owner))
			return false;
		if (!inline_xdr_bytes
		    (xdrs,
		     (char **)&objp->eir_server_scope.eir_server_scope_val,
		     (u_int *) &objp->eir_server_scope.eir_server_scope_len,
		     NFS4_OPAQUE_LIMIT))
			return false;
		if (!xdr_array
		    (xdrs,
		     (char **)&objp->eir_server_impl_id.eir_server_impl_id_val,
		     (u_int *) &objp->eir_server_impl_id.
		     eir_server_impl_id_len, 1, sizeof(nfs_impl_id4),
		     (xdrproc_t) xdr_nfs_impl_id4))
			return false;
		return true;
	}

	static inline bool xdr_EXCHANGE_ID4res(XDR * xdrs,
					       EXCHANGE_ID4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->eir_status))
			return false;
		switch (objp->eir_status) {
		case NFS4_OK:
			if (!xdr_EXCHANGE_ID4resok
			    (xdrs, &objp->EXCHANGE_ID4res_u.eir_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_channel_attrs4(XDR * xdrs, channel_attrs4 * objp)
	{
		if (!xdr_count4(xdrs, &objp->ca_headerpadsize))
			return false;
		if (!xdr_count4(xdrs, &objp->ca_maxrequestsize))
			return false;
		if (!xdr_count4(xdrs, &objp->ca_maxresponsesize))
			return false;
		if (!xdr_count4(xdrs, &objp->ca_maxresponsesize_cached))
			return false;
		if (!xdr_count4(xdrs, &objp->ca_maxoperations))
			return false;
		if (!xdr_count4(xdrs, &objp->ca_maxrequests))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->ca_rdma_ird.ca_rdma_ird_val,
		     (u_int *) &objp->ca_rdma_ird.ca_rdma_ird_len, 1,
		     sizeof(uint32_t), (xdrproc_t) xdr_uint32_t))
			return false;
		return true;
	}

	static inline bool xdr_CREATE_SESSION4args(XDR * xdrs,
						   CREATE_SESSION4args * objp)
	{
		if (!xdr_clientid4(xdrs, &objp->csa_clientid))
			return false;
		if (!xdr_sequenceid4(xdrs, &objp->csa_sequence))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->csa_flags))
			return false;
		if (!xdr_channel_attrs4(xdrs, &objp->csa_fore_chan_attrs))
			return false;
		if (!xdr_channel_attrs4(xdrs, &objp->csa_back_chan_attrs))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->csa_cb_program))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->csa_sec_parms.csa_sec_parms_val,
		     (u_int *) &objp->csa_sec_parms.csa_sec_parms_len, ~0,
		     sizeof(callback_sec_parms4),
		     (xdrproc_t) xdr_callback_sec_parms4))
			return false;
		return true;
	}

	static inline bool xdr_CREATE_SESSION4resok(XDR * xdrs,
						    CREATE_SESSION4resok *
						    objp)
	{
		if (!xdr_sessionid4(xdrs, objp->csr_sessionid))
			return false;
		if (!xdr_sequenceid4(xdrs, &objp->csr_sequence))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->csr_flags))
			return false;
		if (!xdr_channel_attrs4(xdrs, &objp->csr_fore_chan_attrs))
			return false;
		if (!xdr_channel_attrs4(xdrs, &objp->csr_back_chan_attrs))
			return false;
		return true;
	}

	static inline bool xdr_CREATE_SESSION4res(XDR * xdrs,
						  CREATE_SESSION4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->csr_status))
			return false;
		switch (objp->csr_status) {
		case NFS4_OK:
			if (!xdr_CREATE_SESSION4resok
			    (xdrs, &objp->CREATE_SESSION4res_u.csr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_DESTROY_SESSION4args(XDR * xdrs,
						    DESTROY_SESSION4args *
						    objp)
	{
		if (!xdr_sessionid4(xdrs, objp->dsa_sessionid))
			return false;
		return true;
	}

	static inline bool xdr_DESTROY_SESSION4res(XDR * xdrs,
						   DESTROY_SESSION4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->dsr_status))
			return false;
		return true;
	}

	static inline bool xdr_FREE_STATEID4args(XDR * xdrs,
						 FREE_STATEID4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->fsa_stateid))
			return false;
		return true;
	}

	static inline bool xdr_FREE_STATEID4res(XDR * xdrs,
						FREE_STATEID4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->fsr_status))
			return false;
		return true;
	}

	static inline bool xdr_attr_notice4(XDR * xdrs, attr_notice4 * objp)
	{
		if (!xdr_nfstime4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_GET_DIR_DELEGATION4args(XDR * xdrs,
						       GET_DIR_DELEGATION4args *
						       objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->gdda_signal_deleg_avail))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->gdda_notification_types))
			return false;
		if (!xdr_attr_notice4(xdrs, &objp->gdda_child_attr_delay))
			return false;
		if (!xdr_attr_notice4(xdrs, &objp->gdda_dir_attr_delay))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->gdda_child_attributes))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->gdda_dir_attributes))
			return false;
		return true;
	}

	static inline bool xdr_GET_DIR_DELEGATION4resok(XDR * xdrs,
							GET_DIR_DELEGATION4resok
							* objp)
	{
		if (!xdr_verifier4(xdrs, objp->gddr_cookieverf))
			return false;
		if (!xdr_stateid4(xdrs, &objp->gddr_stateid))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->gddr_notification))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->gddr_child_attributes))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->gddr_dir_attributes))
			return false;
		return true;
	}

	static inline bool xdr_gddrnf4_status(XDR * xdrs, gddrnf4_status * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_GET_DIR_DELEGATION4res_non_fatal(
					XDR * xdrs,
					GET_DIR_DELEGATION4res_non_fatal * objp)
	{
		if (!xdr_gddrnf4_status(xdrs, &objp->gddrnf_status))
			return false;
		switch (objp->gddrnf_status) {
		case GDD4_OK:
			if (!xdr_GET_DIR_DELEGATION4resok
			    (xdrs,
			     &objp->GET_DIR_DELEGATION4res_non_fatal_u.
			     gddrnf_resok4))
				return false;
			break;
		case GDD4_UNAVAIL:
			if (!inline_xdr_bool
			    (xdrs,
			     &objp->GET_DIR_DELEGATION4res_non_fatal_u.
			     gddrnf_will_signal_deleg_avail))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_GET_DIR_DELEGATION4res(
					XDR * xdrs,
					GET_DIR_DELEGATION4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->gddr_status))
			return false;
		switch (objp->gddr_status) {
		case NFS4_OK:
			if (!xdr_GET_DIR_DELEGATION4res_non_fatal
			    (xdrs,
			     &objp->GET_DIR_DELEGATION4res_u.
			     gddr_res_non_fatal4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_GETDEVICEINFO4args(XDR * xdrs,
						  GETDEVICEINFO4args * objp)
	{
		if (!xdr_deviceid4(xdrs, objp->gdia_device_id))
			return false;
		if (!xdr_layouttype4(xdrs, &objp->gdia_layout_type))
			return false;
		if (!xdr_count4(xdrs, &objp->gdia_maxcount))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->gdia_notify_types))
			return false;
		return true;
	}

	static inline bool xdr_GETDEVICEINFO4resok(XDR * xdrs,
						   GETDEVICEINFO4resok * objp)
	{
		if (!xdr_device_addr4(xdrs, &objp->gdir_device_addr))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->gdir_notification))
			return false;
		return true;
	}

	static inline bool xdr_GETDEVICEINFO4res(XDR * xdrs,
						 GETDEVICEINFO4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->gdir_status))
			return false;
		switch (objp->gdir_status) {
		case NFS4_OK:
			if (!xdr_GETDEVICEINFO4resok
			    (xdrs, &objp->GETDEVICEINFO4res_u.gdir_resok4))
				return false;
			break;
		case NFS4ERR_TOOSMALL:
			if (!xdr_count4
			    (xdrs, &objp->GETDEVICEINFO4res_u.gdir_mincount))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_GETDEVICELIST4args(XDR * xdrs,
						  GETDEVICELIST4args * objp)
	{
		if (!xdr_layouttype4(xdrs, &objp->gdla_layout_type))
			return false;
		if (!xdr_count4(xdrs, &objp->gdla_maxdevices))
			return false;
		if (!xdr_nfs_cookie4(xdrs, &objp->gdla_cookie))
			return false;
		if (!xdr_verifier4(xdrs, objp->gdla_cookieverf))
			return false;
		return true;
	}

	static inline bool xdr_GETDEVICELIST4resok(XDR * xdrs,
						   GETDEVICELIST4resok * objp)
	{
		if (!xdr_nfs_cookie4(xdrs, &objp->gdlr_cookie))
			return false;
		if (!xdr_verifier4(xdrs, objp->gdlr_cookieverf))
			return false;
		if (!xdr_array
		    (xdrs,
		     (char **)&objp->gdlr_deviceid_list.gdlr_deviceid_list_val,
		     (u_int *) &objp->gdlr_deviceid_list.
		     gdlr_deviceid_list_len, ~0, sizeof(deviceid4),
		     (xdrproc_t) xdr_deviceid4))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->gdlr_eof))
			return false;
		return true;
	}

	static inline bool xdr_GETDEVICELIST4res(XDR * xdrs,
						 GETDEVICELIST4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->gdlr_status))
			return false;
		switch (objp->gdlr_status) {
		case NFS4_OK:
			if (!xdr_GETDEVICELIST4resok
			    (xdrs, &objp->GETDEVICELIST4res_u.gdlr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_newtime4(XDR * xdrs, newtime4 * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->nt_timechanged))
			return false;
		switch (objp->nt_timechanged) {
		case true:
			if (!xdr_nfstime4(xdrs, &objp->newtime4_u.nt_time))
				return false;
			break;
		case false:
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_newoffset4(XDR * xdrs, newoffset4 * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->no_newoffset))
			return false;
		switch (objp->no_newoffset) {
		case true:
			if (!xdr_offset4(xdrs, &objp->newoffset4_u.no_offset))
				return false;
			break;
		case false:
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_LAYOUTCOMMIT4args(XDR * xdrs,
						 LAYOUTCOMMIT4args * objp)
	{
		if (!xdr_offset4(xdrs, &objp->loca_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->loca_length))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->loca_reclaim))
			return false;
		if (!xdr_stateid4(xdrs, &objp->loca_stateid))
			return false;
		if (!xdr_newoffset4(xdrs, &objp->loca_last_write_offset))
			return false;
		if (!xdr_newtime4(xdrs, &objp->loca_time_modify))
			return false;
		if (!xdr_layoutupdate4(xdrs, &objp->loca_layoutupdate))
			return false;
		return true;
	}

	static inline bool xdr_newsize4(XDR * xdrs, newsize4 * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->ns_sizechanged))
			return false;
		switch (objp->ns_sizechanged) {
		case true:
			if (!xdr_length4(xdrs, &objp->newsize4_u.ns_size))
				return false;
			break;
		case false:
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_LAYOUTCOMMIT4resok(XDR * xdrs,
						  LAYOUTCOMMIT4resok * objp)
	{
		if (!xdr_newsize4(xdrs, &objp->locr_newsize))
			return false;
		return true;
	}

	static inline bool xdr_LAYOUTCOMMIT4res(XDR * xdrs,
						LAYOUTCOMMIT4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->locr_status))
			return false;
		switch (objp->locr_status) {
		case NFS4_OK:
			if (!xdr_LAYOUTCOMMIT4resok
			    (xdrs, &objp->LAYOUTCOMMIT4res_u.locr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_LAYOUTGET4args(XDR * xdrs, LAYOUTGET4args * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->loga_signal_layout_avail))
			return false;
		if (!xdr_layouttype4(xdrs, &objp->loga_layout_type))
			return false;
		if (!xdr_layoutiomode4(xdrs, &objp->loga_iomode))
			return false;
		if (!xdr_offset4(xdrs, &objp->loga_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->loga_length))
			return false;
		if (!xdr_length4(xdrs, &objp->loga_minlength))
			return false;
		if (!xdr_stateid4(xdrs, &objp->loga_stateid))
			return false;
		if (!xdr_count4(xdrs, &objp->loga_maxcount))
			return false;
		return true;
	}

	static inline bool xdr_LAYOUTGET4resok(XDR * xdrs,
					       LAYOUTGET4resok * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->logr_return_on_close))
			return false;
		if (!xdr_stateid4(xdrs, &objp->logr_stateid))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->logr_layout.logr_layout_val,
		     (u_int *) &objp->logr_layout.logr_layout_len, ~0,
		     sizeof(layout4), (xdrproc_t) xdr_layout4))
			return false;
		return true;
	}

	static inline bool xdr_LAYOUTGET4res(XDR * xdrs, LAYOUTGET4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->logr_status))
			return false;
		switch (objp->logr_status) {
		case NFS4_OK:
			if (!xdr_LAYOUTGET4resok
			    (xdrs, &objp->LAYOUTGET4res_u.logr_resok4))
				return false;
			break;
		case NFS4ERR_LAYOUTTRYLATER:
			if (!inline_xdr_bool
			    (xdrs,
			     &objp->LAYOUTGET4res_u.
			     logr_will_signal_layout_avail))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_LAYOUTRETURN4args(XDR * xdrs,
						 LAYOUTRETURN4args * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->lora_reclaim))
			return false;
		if (!xdr_layouttype4(xdrs, &objp->lora_layout_type))
			return false;
		if (!xdr_layoutiomode4(xdrs, &objp->lora_iomode))
			return false;
		if (!xdr_layoutreturn4(xdrs, &objp->lora_layoutreturn))
			return false;
		return true;
	}

	static inline bool xdr_layoutreturn_stateid(XDR * xdrs,
						    layoutreturn_stateid *
						    objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->lrs_present))
			return false;
		switch (objp->lrs_present) {
		case true:
			if (!xdr_stateid4
			    (xdrs, &objp->layoutreturn_stateid_u.lrs_stateid))
				return false;
			break;
		case false:
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_LAYOUTRETURN4res(XDR * xdrs,
						LAYOUTRETURN4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->lorr_status))
			return false;
		switch (objp->lorr_status) {
		case NFS4_OK:
			if (!xdr_layoutreturn_stateid
			    (xdrs, &objp->LAYOUTRETURN4res_u.lorr_stateid))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_secinfo_style4(XDR * xdrs, secinfo_style4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_SECINFO_NO_NAME4args(XDR * xdrs,
						    SECINFO_NO_NAME4args *
						    objp)
	{
		if (!xdr_secinfo_style4(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_SECINFO_NO_NAME4res(XDR * xdrs,
						   SECINFO_NO_NAME4res * objp)
	{
		if (!xdr_SECINFO4res(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_SEQUENCE4args(XDR * xdrs, SEQUENCE4args * objp)
	{
		if (!xdr_sessionid4(xdrs, objp->sa_sessionid))
			return false;
		if (!xdr_sequenceid4(xdrs, &objp->sa_sequenceid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->sa_slotid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->sa_highest_slotid))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->sa_cachethis))
			return false;
		return true;
	}

	static inline bool xdr_SEQUENCE4resok(XDR * xdrs, SEQUENCE4resok * objp)
	{
		if (!xdr_sessionid4(xdrs, objp->sr_sessionid))
			return false;
		if (!xdr_sequenceid4(xdrs, &objp->sr_sequenceid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->sr_slotid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->sr_highest_slotid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->sr_target_highest_slotid))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->sr_status_flags))
			return false;
		return true;
	}

	static inline bool xdr_SEQUENCE4res(XDR * xdrs, SEQUENCE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->sr_status))
			return false;
		switch (objp->sr_status) {
		case NFS4_OK:
			if (!xdr_SEQUENCE4resok
			    (xdrs, &objp->SEQUENCE4res_u.sr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_ssa_digest_input4(XDR * xdrs,
						 ssa_digest_input4 * objp)
	{
		if (!xdr_SEQUENCE4args(xdrs, &objp->sdi_seqargs))
			return false;
		return true;
	}

	static inline bool xdr_SET_SSV4args(XDR * xdrs, SET_SSV4args * objp)
	{
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->ssa_ssv.ssa_ssv_val,
		     (u_int *) &objp->ssa_ssv.ssa_ssv_len, ~0))
			return false;
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->ssa_digest.ssa_digest_val,
		     (u_int *) &objp->ssa_digest.ssa_digest_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_ssr_digest_input4(XDR * xdrs,
						 ssr_digest_input4 * objp)
	{
		if (!xdr_SEQUENCE4res(xdrs, &objp->sdi_seqres))
			return false;
		return true;
	}

	static inline bool xdr_SET_SSV4resok(XDR * xdrs, SET_SSV4resok * objp)
	{
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->ssr_digest.ssr_digest_val,
		     (u_int *) &objp->ssr_digest.ssr_digest_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_SET_SSV4res(XDR * xdrs, SET_SSV4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->ssr_status))
			return false;
		switch (objp->ssr_status) {
		case NFS4_OK:
			if (!xdr_SET_SSV4resok
			    (xdrs, &objp->SET_SSV4res_u.ssr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_TEST_STATEID4args(XDR * xdrs,
						 TEST_STATEID4args * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->ts_stateids.ts_stateids_val,
		     (u_int *) &objp->ts_stateids.ts_stateids_len, ~0,
		     sizeof(stateid4), (xdrproc_t) xdr_stateid4))
			return false;
		return true;
	}

	static inline bool xdr_TEST_STATEID4resok(XDR * xdrs,
						  TEST_STATEID4resok * objp)
	{
		if (!xdr_array
		    (xdrs,
		     (char **)&objp->tsr_status_codes.tsr_status_codes_val,
		     (u_int *) &objp->tsr_status_codes.tsr_status_codes_len,
		     ~0, sizeof(nfsstat4), (xdrproc_t) xdr_nfsstat4))
			return false;
		return true;
	}

	static inline bool xdr_TEST_STATEID4res(XDR * xdrs,
						TEST_STATEID4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->tsr_status))
			return false;
		switch (objp->tsr_status) {
		case NFS4_OK:
			if (!xdr_TEST_STATEID4resok
			    (xdrs, &objp->TEST_STATEID4res_u.tsr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_deleg_claim4(XDR * xdrs, deleg_claim4 * objp)
	{
		if (!xdr_open_claim_type4(xdrs, &objp->dc_claim))
			return false;
		switch (objp->dc_claim) {
		case CLAIM_FH:
			break;
		case CLAIM_DELEG_PREV_FH:
			break;
		case CLAIM_PREVIOUS:
			if (!xdr_open_delegation_type4
			    (xdrs, &objp->deleg_claim4_u.dc_delegate_type))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_WANT_DELEGATION4args(XDR * xdrs,
						    WANT_DELEGATION4args *
						    objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->wda_want))
			return false;
		if (!xdr_deleg_claim4(xdrs, &objp->wda_claim))
			return false;
		return true;
	}

	static inline bool xdr_WANT_DELEGATION4res(XDR * xdrs,
						   WANT_DELEGATION4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->wdr_status))
			return false;
		switch (objp->wdr_status) {
		case NFS4_OK:
			if (!xdr_open_delegation4
			    (xdrs, &objp->WANT_DELEGATION4res_u.wdr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_DESTROY_CLIENTID4args(XDR * xdrs,
						     DESTROY_CLIENTID4args *
						     objp)
	{
		if (!xdr_clientid4(xdrs, &objp->dca_clientid))
			return false;
		return true;
	}

	static inline bool xdr_DESTROY_CLIENTID4res(XDR * xdrs,
						    DESTROY_CLIENTID4res *
						    objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->dcr_status))
			return false;
		return true;
	}

	static inline bool xdr_RECLAIM_COMPLETE4args(XDR * xdrs,
						     RECLAIM_COMPLETE4args *
						     objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->rca_one_fs))
			return false;
		return true;
	}

	static inline bool xdr_RECLAIM_COMPLETE4res(XDR * xdrs,
						    RECLAIM_COMPLETE4res *
						    objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->rcr_status))
			return false;
		return true;
	}

	/* NFSv4.2 */
	static inline bool xdr_WRITE_SAME4args(XDR * xdrs,
						WRITE_SAME4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->wp_stateid))
			return false;
		if (!xdr_stable_how4(xdrs, &objp->wp_stable))
			return false;
		if (!xdr_offset4(xdrs,
				&objp->wp_adb.adb_offset))
			return false;
		if (!xdr_length4(xdrs,
			  &objp->wp_adb.adb_block_size))
			return false;
		if (!xdr_length4(xdrs,
			  &objp->wp_adb.adb_block_count))
			return false;
		if (!xdr_length4(xdrs,
			  &objp->wp_adb.adb_reloff_blocknum))
			return false;
		if (!xdr_count4(xdrs,
			  &objp->wp_adb.adb_block_num))
			return false;
		if (!xdr_length4(xdrs,
			&objp->wp_adb.adb_reloff_pattern))
			return false;
		if (!inline_xdr_bytes
		    (xdrs,
		     (char **)&objp->wp_adb.adb_data.data_val,
		     (u_int *)&objp->wp_adb.adb_data.data_len,
		      ~0))
			return false;
		return true;
	}

	static inline bool xdr_WRITE_SAME4resok(XDR * xdrs,
						write_response4 * objp)
	{
		if (!xdr_count4(xdrs, &objp->wr_ids))
			return false;
		if (objp->wr_ids > 1)
			return false;
		if (objp->wr_ids == 1)
			if (!xdr_stateid4(xdrs, &objp->wr_callback_id))
				return false;
		if (!xdr_length4(xdrs, &objp->wr_count))
			return false;
		if (!xdr_stable_how4(xdrs, &objp->wr_committed))
			return false;
		if (!xdr_verifier4(xdrs, objp->wr_writeverf))
			return false;
		return true;
	}

	static inline bool xdr_READ_PLUS4args(XDR * xdrs, READ_PLUS4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->rpa_stateid))
			return false;
		if (!xdr_offset4(xdrs, &objp->rpa_offset))
			return false;
		if (!xdr_count4(xdrs, &objp->rpa_count))
			return false;
		return true;
	}

	static inline bool xdr_READ_PLUS4resok(XDR * xdrs,
						read_plus_res4 * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->rpr_eof))
			return false;
		if (objp->rpr_contents_count != 1)  /* an array of 1 for now */
			return false;
		if (!xdr_count4(xdrs, &objp->rpr_contents_count))
			return false;
		if (!inline_xdr_enum(xdrs, (enum_t *)&objp->rpr_contents.what))
			return false;
		if (objp->rpr_contents.what == NFS4_CONTENT_DATA) {
			if (!xdr_offset4(xdrs,
					&objp->rpr_contents.data.d_offset))
				return false;
			if (!inline_xdr_bytes
			    (xdrs,
			      (char **)&objp->rpr_contents.data.d_data.data_val,
			      (u_int *)&objp->rpr_contents.data.d_data.data_len,
			       ~0))
				return false;
			return true;
		}
		if (objp->rpr_contents.what == NFS4_CONTENT_HOLE) {
			if (!xdr_offset4(xdrs,
					&objp->rpr_contents.hole.di_offset))
				return false;
			if (!xdr_length4(xdrs,
				  &objp->rpr_contents.hole.di_length))
				return false;
			return true;
		} else
			return false;
	}

	static inline bool xdr_READ_PLUS4res(XDR * xdrs, READ_PLUS4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->rpr_status))
			return false;
		switch (objp->rpr_status) {
		case NFS4_OK:
			if (!xdr_READ_PLUS4resok(xdrs,
					&objp->rpr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_WRITE_SAME4res(XDR * xdrs, WRITE_SAME4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->wpr_status))
			return false;
		switch (objp->wpr_status) {
		case NFS4_OK:
			if (!xdr_WRITE_SAME4resok(xdrs,
					&objp->wpr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_SEEK4args(XDR * xdrs, SEEK4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->sa_stateid))
			return false;
		if (!xdr_offset4(xdrs, &objp->sa_offset))
			return false;
		if (!inline_xdr_enum(xdrs, (enum_t *)&objp->sa_what))
			return false;
		return true;
	}

	static inline bool xdr_ALLOCATE4args(XDR * xdrs, ALLOCATE4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->aa_stateid))
			return false;
		if (!xdr_offset4(xdrs, &objp->aa_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->aa_length))
			return false;
		return true;
	}

	static inline bool xdr_DEALLOCATE4args(XDR * xdrs,
						DEALLOCATE4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->da_stateid))
			return false;
		if (!xdr_offset4(xdrs, &objp->da_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->da_length))
			return false;
		return true;
	}

	static inline bool xdr_data_contents(XDR * xdrs, contents * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *)&objp->what))
			return false;
		if (objp->what == NFS4_CONTENT_DATA) {
			if (!xdr_offset4(xdrs,
					&objp->hole.di_offset))
				return false;
			if (!xdr_length4(xdrs,
					&objp->hole.di_length))
				return false;
			return true;
		}
		if (objp->what == NFS4_CONTENT_HOLE) {
			if (!xdr_offset4(xdrs,
					&objp->hole.di_offset))
				return false;
			if (!xdr_length4(xdrs,
				  &objp->hole.di_length))
				return false;
			return true;
		} else
			return false;
	}

	static inline bool xdr_SEEK4resok(XDR * xdrs, seek_res4 * objp)
	{
		if (!inline_xdr_bool(xdrs, &objp->sr_eof))
			return false;
		if (!xdr_offset4(xdrs, &objp->sr_offset))
			return false;
		return true;
	}

	static inline bool xdr_SEEK4res(XDR * xdrs, SEEK4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->sr_status))
			return false;
		switch (objp->sr_status) {
		case NFS4_OK:
			if (!xdr_SEEK4resok(xdrs,
					&objp->sr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_ALLOCATE4res(XDR * xdrs, ALLOCATE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->ar_status))
			return false;
		return true;
	}

	static inline bool xdr_DEALLOCATE4res(XDR * xdrs, DEALLOCATE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->dr_status))
			return false;
		return true;
	}

	static inline bool xdr_IO_ADVISE4args(XDR * xdrs, IO_ADVISE4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->iaa_stateid))
			return false;
		if (!xdr_offset4(xdrs, &objp->iaa_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->iaa_count))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->iaa_hints))
			return false;
		return true;
	}

	static inline bool xdr_IO_ADVISE4res(XDR * xdrs, IO_ADVISE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->iaa_status))
			return false;
		switch (objp->iaa_status) {
		case NFS4_OK:
			if (!xdr_bitmap4(xdrs,
					&objp->iaa_hints))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_LAYOUTERROR4args(XDR * xdrs,
						LAYOUTERROR4args * objp)
	{
		if (!xdr_offset4(xdrs, &objp->lea_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->lea_length))
			return false;
		if (!xdr_stateid4(xdrs, &objp->lea_stateid))
			return false;
		if (!xdr_deviceid4(xdrs, objp->lea_errors.de_deviceid))
			return false;
		if (!xdr_nfsstat4(xdrs, &objp->lea_errors.de_status))
			return false;
		if (!inline_xdr_enum(xdrs, (enum_t *)objp->lea_errors.de_opnum))
			return false;
		return true;
	}

	static inline bool xdr_LAYOUTERROR4res(XDR * xdrs,
						LAYOUTERROR4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->ler_status))
			return false;
		return true;
	}

	static inline bool xdr_LAYOUTSTATS4args(XDR * xdrs,
						LAYOUTSTATS4args * objp)
	{
		if (!xdr_offset4(xdrs, &objp->lsa_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->lsa_length))
			return false;
		if (!xdr_stateid4(xdrs, &objp->lsa_stateid))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->lsa_read.ii_count))
			return false;
		if (!inline_xdr_u_int64_t(xdrs, &objp->lsa_read.ii_bytes))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->lsa_write.ii_count))
			return false;
		if (!inline_xdr_u_int64_t(xdrs, &objp->lsa_write.ii_bytes))
			return false;
		if (!xdr_layoutupdate4(xdrs, &objp->lsa_layoutupdate))
			return false;
		return true;
	}

	static inline bool xdr_LAYOUTSTATS4res(XDR * xdrs,
						LAYOUTSTATS4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->lsr_status))
			return false;
		return true;
	}

/* new operations for NFSv4.1 */

	static inline bool xdr_nfs_opnum4(XDR * xdrs, nfs_opnum4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_nfs_argop4(XDR * xdrs, nfs_argop4 * objp)
	{
		struct nfs_request_lookahead slhd = {
			.flags = 0,
			.read = 0,
			.write = 0
		};
		struct nfs_request_lookahead *lkhd =
		    xdrs->x_public ? (struct nfs_request_lookahead *)xdrs->
		    x_public : &slhd;

		if (!xdr_nfs_opnum4(xdrs, &objp->argop))
			return false;
		switch (objp->argop) {
		case NFS4_OP_ACCESS:
			if (!xdr_ACCESS4args
			    (xdrs, &objp->nfs_argop4_u.opaccess))
				return false;
			break;
		case NFS4_OP_CLOSE:
			if (!xdr_CLOSE4args(xdrs, &objp->nfs_argop4_u.opclose))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_CLOSE;
			break;
		case NFS4_OP_COMMIT:
			if (!xdr_COMMIT4args
			    (xdrs, &objp->nfs_argop4_u.opcommit))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_COMMIT;
			break;
		case NFS4_OP_CREATE:
			if (!xdr_CREATE4args
			    (xdrs, &objp->nfs_argop4_u.opcreate))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_CREATE;
			break;
		case NFS4_OP_DELEGPURGE:
			if (!xdr_DELEGPURGE4args
			    (xdrs, &objp->nfs_argop4_u.opdelegpurge))
				return false;
			break;
		case NFS4_OP_DELEGRETURN:
			if (!xdr_DELEGRETURN4args
			    (xdrs, &objp->nfs_argop4_u.opdelegreturn))
				return false;
			break;
		case NFS4_OP_GETATTR:
			if (!xdr_GETATTR4args
			    (xdrs, &objp->nfs_argop4_u.opgetattr))
				return false;
			break;
		case NFS4_OP_GETFH:
			break;
		case NFS4_OP_LINK:
			if (!xdr_LINK4args(xdrs, &objp->nfs_argop4_u.oplink))
				return false;
			break;
		case NFS4_OP_LOCK:
			if (!xdr_LOCK4args(xdrs, &objp->nfs_argop4_u.oplock))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_LOCK;
			break;
		case NFS4_OP_LOCKT:
			if (!xdr_LOCKT4args(xdrs, &objp->nfs_argop4_u.oplockt))
				return false;
			break;
		case NFS4_OP_LOCKU:
			if (!xdr_LOCKU4args(xdrs, &objp->nfs_argop4_u.oplocku))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_LOCK;
			break;
		case NFS4_OP_LOOKUP:
			if (!xdr_LOOKUP4args
			    (xdrs, &objp->nfs_argop4_u.oplookup))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_LOOKUP;
			break;
		case NFS4_OP_LOOKUPP:
			lkhd->flags |= NFS_LOOKAHEAD_LOOKUP;
			break;
		case NFS4_OP_NVERIFY:
			if (!xdr_NVERIFY4args
			    (xdrs, &objp->nfs_argop4_u.opnverify))
				return false;
			break;
		case NFS4_OP_OPEN:
			if (!xdr_OPEN4args(xdrs, &objp->nfs_argop4_u.opopen))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_OPEN;
			if (objp->nfs_argop4_u.opopen.openhow.opentype ==
			    OPEN4_CREATE)
				lkhd->flags |= NFS_LOOKAHEAD_CREATE;
			break;
		case NFS4_OP_OPENATTR:
			if (!xdr_OPENATTR4args
			    (xdrs, &objp->nfs_argop4_u.opopenattr))
				return false;
			break;
		case NFS4_OP_OPEN_CONFIRM:
			if (!xdr_OPEN_CONFIRM4args
			    (xdrs, &objp->nfs_argop4_u.opopen_confirm))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_OPEN;
			break;
		case NFS4_OP_OPEN_DOWNGRADE:
			if (!xdr_OPEN_DOWNGRADE4args
			    (xdrs, &objp->nfs_argop4_u.opopen_downgrade))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_OPEN;
			break;
		case NFS4_OP_PUTFH:
			if (!xdr_PUTFH4args(xdrs, &objp->nfs_argop4_u.opputfh))
				return false;
			break;
		case NFS4_OP_PUTPUBFH:
			break;
		case NFS4_OP_PUTROOTFH:
			break;
		case NFS4_OP_READ:
			if (!xdr_READ4args(xdrs, &objp->nfs_argop4_u.opread))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_READ;
			(lkhd->read)++;
			break;
		case NFS4_OP_READDIR:
			if (!xdr_READDIR4args
			    (xdrs, &objp->nfs_argop4_u.opreaddir))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_READDIR;
			break;
		case NFS4_OP_READLINK:
			lkhd->flags |= NFS_LOOKAHEAD_READLINK;
			break;
		case NFS4_OP_REMOVE:
			if (!xdr_REMOVE4args
			    (xdrs, &objp->nfs_argop4_u.opremove))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_REMOVE;
			break;
		case NFS4_OP_RENAME:
			if (!xdr_RENAME4args
			    (xdrs, &objp->nfs_argop4_u.oprename))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_RENAME;
			break;
		case NFS4_OP_RENEW:
			if (!xdr_RENEW4args(xdrs, &objp->nfs_argop4_u.oprenew))
				return false;
			break;
		case NFS4_OP_RESTOREFH:
			break;
		case NFS4_OP_SAVEFH:
			break;
		case NFS4_OP_SECINFO:
			if (!xdr_SECINFO4args
			    (xdrs, &objp->nfs_argop4_u.opsecinfo))
				return false;
			break;
		case NFS4_OP_SETATTR:
			if (!xdr_SETATTR4args
			    (xdrs, &objp->nfs_argop4_u.opsetattr))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_SETATTR;
			break;
		case NFS4_OP_SETCLIENTID:
			if (!xdr_SETCLIENTID4args
			    (xdrs, &objp->nfs_argop4_u.opsetclientid))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_SETCLIENTID;
			break;
		case NFS4_OP_SETCLIENTID_CONFIRM:
			if (!xdr_SETCLIENTID_CONFIRM4args
			    (xdrs, &objp->nfs_argop4_u.opsetclientid_confirm))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_SETCLIENTID_CONFIRM;
			break;
		case NFS4_OP_VERIFY:
			if (!xdr_VERIFY4args
			    (xdrs, &objp->nfs_argop4_u.opverify))
				return false;
			break;
		case NFS4_OP_WRITE:
			if (!xdr_WRITE4args(xdrs, &objp->nfs_argop4_u.opwrite))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_WRITE;
			(lkhd->write)++;
			break;
		case NFS4_OP_RELEASE_LOCKOWNER:
			if (!xdr_RELEASE_LOCKOWNER4args
			    (xdrs, &objp->nfs_argop4_u.oprelease_lockowner))
				return false;
			break;
		case NFS4_OP_BACKCHANNEL_CTL:
			if (!xdr_BACKCHANNEL_CTL4args
			    (xdrs, &objp->nfs_argop4_u.opbackchannel_ctl))
				return false;
			break;
		case NFS4_OP_BIND_CONN_TO_SESSION:
			if (!xdr_BIND_CONN_TO_SESSION4args
			    (xdrs, &objp->nfs_argop4_u.opbind_conn_to_session))
				return false;
			break;
		case NFS4_OP_EXCHANGE_ID:
			if (!xdr_EXCHANGE_ID4args
			    (xdrs, &objp->nfs_argop4_u.opexchange_id))
				return false;
			break;
		case NFS4_OP_CREATE_SESSION:
			if (!xdr_CREATE_SESSION4args
			    (xdrs, &objp->nfs_argop4_u.opcreate_session))
				return false;
			break;
		case NFS4_OP_DESTROY_SESSION:
			if (!xdr_DESTROY_SESSION4args
			    (xdrs, &objp->nfs_argop4_u.opdestroy_session))
				return false;
			break;
		case NFS4_OP_FREE_STATEID:
			if (!xdr_FREE_STATEID4args
			    (xdrs, &objp->nfs_argop4_u.opfree_stateid))
				return false;
			break;
		case NFS4_OP_GET_DIR_DELEGATION:
			if (!xdr_GET_DIR_DELEGATION4args
			    (xdrs, &objp->nfs_argop4_u.opget_dir_delegation))
				return false;
			break;
		case NFS4_OP_GETDEVICEINFO:
			if (!xdr_GETDEVICEINFO4args
			    (xdrs, &objp->nfs_argop4_u.opgetdeviceinfo))
				return false;
			break;
		case NFS4_OP_GETDEVICELIST:
			if (!xdr_GETDEVICELIST4args
			    (xdrs, &objp->nfs_argop4_u.opgetdevicelist))
				return false;
			break;
		case NFS4_OP_LAYOUTCOMMIT:
			if (!xdr_LAYOUTCOMMIT4args
			    (xdrs, &objp->nfs_argop4_u.oplayoutcommit))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_LAYOUTCOMMIT;
			break;
		case NFS4_OP_LAYOUTGET:
			if (!xdr_LAYOUTGET4args
			    (xdrs, &objp->nfs_argop4_u.oplayoutget))
				return false;
			break;
		case NFS4_OP_LAYOUTRETURN:
			if (!xdr_LAYOUTRETURN4args
			    (xdrs, &objp->nfs_argop4_u.oplayoutreturn))
				return false;
			break;
		case NFS4_OP_SECINFO_NO_NAME:
			if (!xdr_SECINFO_NO_NAME4args
			    (xdrs, &objp->nfs_argop4_u.opsecinfo_no_name))
				return false;
			break;
		case NFS4_OP_SEQUENCE:
			if (!xdr_SEQUENCE4args
			    (xdrs, &objp->nfs_argop4_u.opsequence))
				return false;
			break;
		case NFS4_OP_SET_SSV:
			if (!xdr_SET_SSV4args
			    (xdrs, &objp->nfs_argop4_u.opset_ssv))
				return false;
			break;
		case NFS4_OP_TEST_STATEID:
			if (!xdr_TEST_STATEID4args
			    (xdrs, &objp->nfs_argop4_u.optest_stateid))
				return false;
			break;
		case NFS4_OP_WANT_DELEGATION:
			if (!xdr_WANT_DELEGATION4args
			    (xdrs, &objp->nfs_argop4_u.opwant_delegation))
				return false;
			break;
		case NFS4_OP_DESTROY_CLIENTID:
			if (!xdr_DESTROY_CLIENTID4args
			    (xdrs, &objp->nfs_argop4_u.opdestroy_clientid))
				return false;
			break;
		case NFS4_OP_RECLAIM_COMPLETE:
			if (!xdr_RECLAIM_COMPLETE4args
			    (xdrs, &objp->nfs_argop4_u.opreclaim_complete))
				return false;
			break;

		/* NFSv4.2 */
		case NFS4_OP_WRITE_SAME:
			if (!xdr_WRITE_SAME4args(xdrs,
					&objp->nfs_argop4_u.opwrite_plus))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_WRITE;
			(lkhd->write)++;
			break;
		case NFS4_OP_READ_PLUS:
			if (!xdr_READ_PLUS4args(xdrs,
					&objp->nfs_argop4_u.opread_plus))
				return false;
			lkhd->flags |= NFS_LOOKAHEAD_READ;
			(lkhd->read)++;
			break;
		case NFS4_OP_SEEK:
			if (!xdr_SEEK4args(xdrs,
					&objp->nfs_argop4_u.opseek))
				return false;
			break;
		case NFS4_OP_ALLOCATE:
			if (!xdr_ALLOCATE4args(xdrs,
					&objp->nfs_argop4_u.opallocate))
				return false;
			break;
		case NFS4_OP_DEALLOCATE:
			if (!xdr_DEALLOCATE4args(xdrs,
					&objp->nfs_argop4_u.opdeallocate))
				return false;
			break;
		case NFS4_OP_IO_ADVISE:
			if (!xdr_IO_ADVISE4args(xdrs,
					&objp->nfs_argop4_u.opio_advise))
				return false;
			break;
		case NFS4_OP_LAYOUTERROR:
			if (!xdr_LAYOUTERROR4args(xdrs,
					&objp->nfs_argop4_u.oplayouterror))
				return false;
			break;
		case NFS4_OP_LAYOUTSTATS:
			if (!xdr_LAYOUTSTATS4args(xdrs,
					&objp->nfs_argop4_u.oplayoutstats))
				return false;
			break;

		case NFS4_OP_COPY:
		case NFS4_OP_COPY_NOTIFY:
		case NFS4_OP_OFFLOAD_CANCEL:
		case NFS4_OP_OFFLOAD_STATUS:
			break;

		case NFS4_OP_ILLEGAL:
			break;
		default:
			/* Avoid transforming unknown opcodes as RPC
			 * decoder errors
			 */
			objp->argop = NFS4_OP_ILLEGAL;
			break;
		}
		return true;
	}

	static inline bool xdr_nfs_resop4(XDR * xdrs, nfs_resop4 * objp)
	{
		if (!xdr_nfs_opnum4(xdrs, &objp->resop))
			return false;
		switch (objp->resop) {
		case NFS4_OP_ACCESS:
			if (!xdr_ACCESS4res(xdrs, &objp->nfs_resop4_u.opaccess))
				return false;
			break;
		case NFS4_OP_CLOSE:
			if (!xdr_CLOSE4res(xdrs, &objp->nfs_resop4_u.opclose))
				return false;
			break;
		case NFS4_OP_COMMIT:
			if (!xdr_COMMIT4res(xdrs, &objp->nfs_resop4_u.opcommit))
				return false;
			break;
		case NFS4_OP_CREATE:
			if (!xdr_CREATE4res(xdrs, &objp->nfs_resop4_u.opcreate))
				return false;
			break;
		case NFS4_OP_DELEGPURGE:
			if (!xdr_DELEGPURGE4res
			    (xdrs, &objp->nfs_resop4_u.opdelegpurge))
				return false;
			break;
		case NFS4_OP_DELEGRETURN:
			if (!xdr_DELEGRETURN4res
			    (xdrs, &objp->nfs_resop4_u.opdelegreturn))
				return false;
			break;
		case NFS4_OP_GETATTR:
			if (!xdr_GETATTR4res
			    (xdrs, &objp->nfs_resop4_u.opgetattr))
				return false;
			break;
		case NFS4_OP_GETFH:
			if (!xdr_GETFH4res(xdrs, &objp->nfs_resop4_u.opgetfh))
				return false;
			break;
		case NFS4_OP_LINK:
			if (!xdr_LINK4res(xdrs, &objp->nfs_resop4_u.oplink))
				return false;
			break;
		case NFS4_OP_LOCK:
			if (!xdr_LOCK4res(xdrs, &objp->nfs_resop4_u.oplock))
				return false;
			break;
		case NFS4_OP_LOCKT:
			if (!xdr_LOCKT4res(xdrs, &objp->nfs_resop4_u.oplockt))
				return false;
			break;
		case NFS4_OP_LOCKU:
			if (!xdr_LOCKU4res(xdrs, &objp->nfs_resop4_u.oplocku))
				return false;
			break;
		case NFS4_OP_LOOKUP:
			if (!xdr_LOOKUP4res(xdrs, &objp->nfs_resop4_u.oplookup))
				return false;
			break;
		case NFS4_OP_LOOKUPP:
			if (!xdr_LOOKUPP4res
			    (xdrs, &objp->nfs_resop4_u.oplookupp))
				return false;
			break;
		case NFS4_OP_NVERIFY:
			if (!xdr_NVERIFY4res
			    (xdrs, &objp->nfs_resop4_u.opnverify))
				return false;
			break;
		case NFS4_OP_OPEN:
			if (!xdr_OPEN4res(xdrs, &objp->nfs_resop4_u.opopen))
				return false;
			break;
		case NFS4_OP_OPENATTR:
			if (!xdr_OPENATTR4res
			    (xdrs, &objp->nfs_resop4_u.opopenattr))
				return false;
			break;
		case NFS4_OP_OPEN_CONFIRM:
			if (!xdr_OPEN_CONFIRM4res
			    (xdrs, &objp->nfs_resop4_u.opopen_confirm))
				return false;
			break;
		case NFS4_OP_OPEN_DOWNGRADE:
			if (!xdr_OPEN_DOWNGRADE4res
			    (xdrs, &objp->nfs_resop4_u.opopen_downgrade))
				return false;
			break;
		case NFS4_OP_PUTFH:
			if (!xdr_PUTFH4res(xdrs, &objp->nfs_resop4_u.opputfh))
				return false;
			break;
		case NFS4_OP_PUTPUBFH:
			if (!xdr_PUTPUBFH4res
			    (xdrs, &objp->nfs_resop4_u.opputpubfh))
				return false;
			break;
		case NFS4_OP_PUTROOTFH:
			if (!xdr_PUTROOTFH4res
			    (xdrs, &objp->nfs_resop4_u.opputrootfh))
				return false;
			break;
		case NFS4_OP_READ:
			if (!xdr_READ4res(xdrs, &objp->nfs_resop4_u.opread))
				return false;
			break;
		case NFS4_OP_READDIR:
			if (!xdr_READDIR4res
			    (xdrs, &objp->nfs_resop4_u.opreaddir))
				return false;
			break;
		case NFS4_OP_READLINK:
			if (!xdr_READLINK4res
			    (xdrs, &objp->nfs_resop4_u.opreadlink))
				return false;
			break;
		case NFS4_OP_REMOVE:
			if (!xdr_REMOVE4res(xdrs, &objp->nfs_resop4_u.opremove))
				return false;
			break;
		case NFS4_OP_RENAME:
			if (!xdr_RENAME4res(xdrs, &objp->nfs_resop4_u.oprename))
				return false;
			break;
		case NFS4_OP_RENEW:
			if (!xdr_RENEW4res(xdrs, &objp->nfs_resop4_u.oprenew))
				return false;
			break;
		case NFS4_OP_RESTOREFH:
			if (!xdr_RESTOREFH4res
			    (xdrs, &objp->nfs_resop4_u.oprestorefh))
				return false;
			break;
		case NFS4_OP_SAVEFH:
			if (!xdr_SAVEFH4res(xdrs, &objp->nfs_resop4_u.opsavefh))
				return false;
			break;
		case NFS4_OP_SECINFO:
			if (!xdr_SECINFO4res
			    (xdrs, &objp->nfs_resop4_u.opsecinfo))
				return false;
			break;
		case NFS4_OP_SETATTR:
			if (!xdr_SETATTR4res
			    (xdrs, &objp->nfs_resop4_u.opsetattr))
				return false;
			break;
		case NFS4_OP_SETCLIENTID:
			if (!xdr_SETCLIENTID4res
			    (xdrs, &objp->nfs_resop4_u.opsetclientid))
				return false;
			break;
		case NFS4_OP_SETCLIENTID_CONFIRM:
			if (!xdr_SETCLIENTID_CONFIRM4res
			    (xdrs, &objp->nfs_resop4_u.opsetclientid_confirm))
				return false;
			break;
		case NFS4_OP_VERIFY:
			if (!xdr_VERIFY4res(xdrs, &objp->nfs_resop4_u.opverify))
				return false;
			break;
		case NFS4_OP_WRITE:
			if (!xdr_WRITE4res(xdrs, &objp->nfs_resop4_u.opwrite))
				return false;
			break;
		case NFS4_OP_RELEASE_LOCKOWNER:
			if (!xdr_RELEASE_LOCKOWNER4res
			    (xdrs, &objp->nfs_resop4_u.oprelease_lockowner))
				return false;
			break;
		case NFS4_OP_BACKCHANNEL_CTL:
			if (!xdr_BACKCHANNEL_CTL4res
			    (xdrs, &objp->nfs_resop4_u.opbackchannel_ctl))
				return false;
			break;
		case NFS4_OP_BIND_CONN_TO_SESSION:
			if (!xdr_BIND_CONN_TO_SESSION4res
			    (xdrs, &objp->nfs_resop4_u.opbind_conn_to_session))
				return false;
			break;
		case NFS4_OP_EXCHANGE_ID:
			if (!xdr_EXCHANGE_ID4res
			    (xdrs, &objp->nfs_resop4_u.opexchange_id))
				return false;
			break;
		case NFS4_OP_CREATE_SESSION:
			if (!xdr_CREATE_SESSION4res
			    (xdrs, &objp->nfs_resop4_u.opcreate_session))
				return false;
			break;
		case NFS4_OP_DESTROY_SESSION:
			if (!xdr_DESTROY_SESSION4res
			    (xdrs, &objp->nfs_resop4_u.opdestroy_session))
				return false;
			break;
		case NFS4_OP_FREE_STATEID:
			if (!xdr_FREE_STATEID4res
			    (xdrs, &objp->nfs_resop4_u.opfree_stateid))
				return false;
			break;
		case NFS4_OP_GET_DIR_DELEGATION:
			if (!xdr_GET_DIR_DELEGATION4res
			    (xdrs, &objp->nfs_resop4_u.opget_dir_delegation))
				return false;
			break;
		case NFS4_OP_GETDEVICEINFO:
			if (!xdr_GETDEVICEINFO4res
			    (xdrs, &objp->nfs_resop4_u.opgetdeviceinfo))
				return false;
			break;
		case NFS4_OP_GETDEVICELIST:
			if (!xdr_GETDEVICELIST4res
			    (xdrs, &objp->nfs_resop4_u.opgetdevicelist))
				return false;
			break;
		case NFS4_OP_LAYOUTCOMMIT:
			if (!xdr_LAYOUTCOMMIT4res
			    (xdrs, &objp->nfs_resop4_u.oplayoutcommit))
				return false;
			break;
		case NFS4_OP_LAYOUTGET:
			if (!xdr_LAYOUTGET4res
			    (xdrs, &objp->nfs_resop4_u.oplayoutget))
				return false;
			break;
		case NFS4_OP_LAYOUTRETURN:
			if (!xdr_LAYOUTRETURN4res
			    (xdrs, &objp->nfs_resop4_u.oplayoutreturn))
				return false;
			break;
		case NFS4_OP_SECINFO_NO_NAME:
			if (!xdr_SECINFO_NO_NAME4res
			    (xdrs, &objp->nfs_resop4_u.opsecinfo_no_name))
				return false;
			break;
		case NFS4_OP_SEQUENCE:
			if (!xdr_SEQUENCE4res
			    (xdrs, &objp->nfs_resop4_u.opsequence))
				return false;
			break;
		case NFS4_OP_SET_SSV:
			if (!xdr_SET_SSV4res
			    (xdrs, &objp->nfs_resop4_u.opset_ssv))
				return false;
			break;
		case NFS4_OP_TEST_STATEID:
			if (!xdr_TEST_STATEID4res
			    (xdrs, &objp->nfs_resop4_u.optest_stateid))
				return false;
			break;
		case NFS4_OP_WANT_DELEGATION:
			if (!xdr_WANT_DELEGATION4res
			    (xdrs, &objp->nfs_resop4_u.opwant_delegation))
				return false;
			break;
		case NFS4_OP_DESTROY_CLIENTID:
			if (!xdr_DESTROY_CLIENTID4res
			    (xdrs, &objp->nfs_resop4_u.opdestroy_clientid))
				return false;
			break;
		case NFS4_OP_RECLAIM_COMPLETE:
			if (!xdr_RECLAIM_COMPLETE4res
			    (xdrs, &objp->nfs_resop4_u.opreclaim_complete))
				return false;
			break;

		/* NFSv4.2 */
		case NFS4_OP_WRITE_SAME:
			if (!xdr_WRITE_SAME4res
			    (xdrs, &objp->nfs_resop4_u.opwrite_plus))
				return false;
			break;
		case NFS4_OP_READ_PLUS:
			if (!xdr_READ_PLUS4res
			    (xdrs, &objp->nfs_resop4_u.opread_plus))
				return false;
			break;
		case NFS4_OP_SEEK:
			if (!xdr_SEEK4res
			    (xdrs, &objp->nfs_resop4_u.opseek))
				return false;
			break;
		case NFS4_OP_ALLOCATE:
			if (!xdr_ALLOCATE4res
			    (xdrs, &objp->nfs_resop4_u.opallocate))
				return false;
			break;
		case NFS4_OP_DEALLOCATE:
			if (!xdr_DEALLOCATE4res
			    (xdrs, &objp->nfs_resop4_u.opdeallocate))
				return false;
			break;
		case NFS4_OP_IO_ADVISE:
			if (!xdr_IO_ADVISE4res
			    (xdrs, &objp->nfs_resop4_u.opio_advise))
				return false;
			break;
		case NFS4_OP_LAYOUTERROR:
			if (!xdr_LAYOUTERROR4res(xdrs,
					&objp->nfs_resop4_u.oplayouterror))
				return false;
			break;
		case NFS4_OP_LAYOUTSTATS:
			if (!xdr_LAYOUTSTATS4res(xdrs,
					&objp->nfs_resop4_u.oplayoutstats))
				return false;
			break;

		case NFS4_OP_COPY:
		case NFS4_OP_COPY_NOTIFY:
		case NFS4_OP_OFFLOAD_CANCEL:
		case NFS4_OP_OFFLOAD_STATUS:

		case NFS4_OP_ILLEGAL:
			if (!xdr_ILLEGAL4res
			    (xdrs, &objp->nfs_resop4_u.opillegal))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_COMPOUND4args(XDR * xdrs, COMPOUND4args * objp)
	{
		if (!xdr_utf8str_cs(xdrs, &objp->tag))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->minorversion))
			return false;
		/* decoder hint */
		if (objp->minorversion > 0)
			xdrs->x_flags &= ~XDR_FLAG_CKSUM;
		if (!xdr_array
		    (xdrs, (char **)&objp->argarray.argarray_val,
		     (u_int *) &objp->argarray.argarray_len, ~0,
		     sizeof(nfs_argop4), (xdrproc_t) xdr_nfs_argop4))
			return false;
		return true;
	}

	static inline bool xdr_COMPOUND4res(XDR * xdrs, COMPOUND4res *objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		if (!xdr_utf8str_cs(xdrs, &objp->tag))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->resarray.resarray_val,
		     (u_int *) &objp->resarray.resarray_len, ~0,
		     sizeof(nfs_resop4), (xdrproc_t) xdr_nfs_resop4))
			return false;
		return true;
	}

	static inline bool xdr_CB_GETATTR4args(XDR * xdrs,
					       CB_GETATTR4args * objp)
	{
		if (!xdr_nfs_fh4(xdrs, &objp->fh))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->attr_request))
			return false;
		return true;
	}

	static inline bool xdr_CB_GETATTR4resok(XDR * xdrs,
						CB_GETATTR4resok * objp)
	{
		if (!xdr_fattr4(xdrs, &objp->obj_attributes))
			return false;
		return true;
	}

	static inline bool xdr_CB_GETATTR4res(XDR * xdrs, CB_GETATTR4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		switch (objp->status) {
		case NFS4_OK:
			if (!xdr_CB_GETATTR4resok
			    (xdrs, &objp->CB_GETATTR4res_u.resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_CB_RECALL4args(XDR * xdrs, CB_RECALL4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->stateid))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->truncate))
			return false;
		if (!xdr_nfs_fh4(xdrs, &objp->fh))
			return false;
		return true;
	}

	static inline bool xdr_CB_RECALL4res(XDR * xdrs, CB_RECALL4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_CB_ILLEGAL4res(XDR * xdrs, CB_ILLEGAL4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		return true;
	}

	static inline bool xdr_layoutrecall_type4(XDR * xdrs,
						  layoutrecall_type4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_layoutrecall_file4(XDR * xdrs,
						  layoutrecall_file4 * objp)
	{
		if (!xdr_nfs_fh4(xdrs, &objp->lor_fh))
			return false;
		if (!xdr_offset4(xdrs, &objp->lor_offset))
			return false;
		if (!xdr_length4(xdrs, &objp->lor_length))
			return false;
		if (!xdr_stateid4(xdrs, &objp->lor_stateid))
			return false;
		return true;
	}

	static inline bool xdr_layoutrecall4(XDR * xdrs, layoutrecall4 * objp)
	{
		if (!xdr_layoutrecall_type4(xdrs, &objp->lor_recalltype))
			return false;
		switch (objp->lor_recalltype) {
		case LAYOUTRECALL4_FILE:
			if (!xdr_layoutrecall_file4
			    (xdrs, &objp->layoutrecall4_u.lor_layout))
				return false;
			break;
		case LAYOUTRECALL4_FSID:
			if (!xdr_fsid4(xdrs, &objp->layoutrecall4_u.lor_fsid))
				return false;
			break;
		case LAYOUTRECALL4_ALL:
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_CB_LAYOUTRECALL4args(XDR * xdrs,
						    CB_LAYOUTRECALL4args *
						    objp)
	{
		if (!xdr_layouttype4(xdrs, &objp->clora_type))
			return false;
		if (!xdr_layoutiomode4(xdrs, &objp->clora_iomode))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->clora_changed))
			return false;
		if (!xdr_layoutrecall4(xdrs, &objp->clora_recall))
			return false;
		return true;
	}

	static inline bool xdr_CB_LAYOUTRECALL4res(XDR * xdrs,
						   CB_LAYOUTRECALL4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->clorr_status))
			return false;
		return true;
	}

	static inline bool xdr_notify_type4(XDR * xdrs, notify_type4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_notify_entry4(XDR * xdrs, notify_entry4 * objp)
	{
		if (!xdr_component4(xdrs, &objp->ne_file))
			return false;
		if (!xdr_fattr4(xdrs, &objp->ne_attrs))
			return false;
		return true;
	}

	static inline bool xdr_prev_entry4(XDR * xdrs, prev_entry4 * objp)
	{
		if (!xdr_notify_entry4(xdrs, &objp->pe_prev_entry))
			return false;
		if (!xdr_nfs_cookie4(xdrs, &objp->pe_prev_entry_cookie))
			return false;
		return true;
	}

	static inline bool xdr_notify_remove4(XDR * xdrs, notify_remove4 * objp)
	{
		if (!xdr_notify_entry4(xdrs, &objp->nrm_old_entry))
			return false;
		if (!xdr_nfs_cookie4(xdrs, &objp->nrm_old_entry_cookie))
			return false;
		return true;
	}

	static inline bool xdr_notify_add4(XDR * xdrs, notify_add4 * objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->nad_old_entry.nad_old_entry_val,
		     (u_int *) &objp->nad_old_entry.nad_old_entry_len, 1,
		     sizeof(notify_remove4), (xdrproc_t) xdr_notify_remove4))
			return false;
		if (!xdr_notify_entry4(xdrs, &objp->nad_new_entry))
			return false;
		if (!xdr_array
		    (xdrs,
		     (char **)&objp->nad_new_entry_cookie.
		     nad_new_entry_cookie_val,
		     (u_int *) &objp->nad_new_entry_cookie.
		     nad_new_entry_cookie_len, 1, sizeof(nfs_cookie4),
		     (xdrproc_t) xdr_nfs_cookie4))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->nad_prev_entry.nad_prev_entry_val,
		     (u_int *) &objp->nad_prev_entry.nad_prev_entry_len, 1,
		     sizeof(prev_entry4), (xdrproc_t) xdr_prev_entry4))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->nad_last_entry))
			return false;
		return true;
	}

	static inline bool xdr_notify_attr4(XDR * xdrs, notify_attr4 * objp)
	{
		if (!xdr_notify_entry4(xdrs, &objp->na_changed_entry))
			return false;
		return true;
	}

	static inline bool xdr_notify_rename4(XDR * xdrs, notify_rename4 * objp)
	{
		if (!xdr_notify_remove4(xdrs, &objp->nrn_old_entry))
			return false;
		if (!xdr_notify_add4(xdrs, &objp->nrn_new_entry))
			return false;
		return true;
	}

	static inline bool xdr_notify_verifier4(XDR * xdrs,
						notify_verifier4 * objp)
	{
		if (!xdr_verifier4(xdrs, objp->nv_old_cookieverf))
			return false;
		if (!xdr_verifier4(xdrs, objp->nv_new_cookieverf))
			return false;
		return true;
	}

	static inline bool xdr_notify_deviceid_delete4(XDR * xdrs,
						       notify_deviceid_delete4 *
						       objp)
	{
		if (!xdr_layouttype4(xdrs, &objp->ndd_layouttype))
			return false;
		if (!xdr_deviceid4(xdrs, objp->ndd_deviceid))
			return false;
		return true;
	}

	static inline bool xdr_notify_deviceid_change4(XDR * xdrs,
						       notify_deviceid_change4 *
						       objp)
	{
		if (!xdr_layouttype4(xdrs, &objp->ndc_layouttype))
			return false;
		if (!xdr_deviceid4(xdrs, objp->ndc_deviceid))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->ndc_immediate))
			return false;
		return true;
	}

	static inline bool xdr_notifylist4(XDR * xdrs, notifylist4 * objp)
	{
		if (!inline_xdr_bytes
		    (xdrs, (char **)&objp->notifylist4_val,
		     (u_int *) &objp->notifylist4_len, ~0))
			return false;
		return true;
	}

	static inline bool xdr_notifylist_dev(XDR * xdrs, notifylist4 * objp,
					      int type)
	{
		if (!xdr_count4(xdrs, &objp->notifylist4_len))
			return false;
		if (type == NOTIFY_DEVICEID4_DELETE_MASK) {
			if (!xdr_notify_deviceid_delete4
			    (xdrs,
			     (notify_deviceid_delete4 *) objp->notifylist4_val))
				return false;
		} else {
			if (!xdr_notify_deviceid_change4
			    (xdrs,
			     (notify_deviceid_change4 *) objp->notifylist4_val))
				return false;
		}
		return true;
	}

	static inline bool xdr_notify4(XDR * xdrs, notify4 * objp)
	{
		if (!xdr_bitmap4(xdrs, &objp->notify_mask))
			return false;
		if (!xdr_notifylist4(xdrs, &objp->notify_vals))
			return false;
		return true;
	}

	static inline bool xdr_notify_dev(XDR * xdrs, notify4 * objp)
	{
		if (!xdr_bitmap4(xdrs, &objp->notify_mask))
			return false;
		if (!xdr_notifylist_dev
		    (xdrs, &objp->notify_vals, objp->notify_mask.map[0]))
			return false;
		return true;
	}

	static inline bool xdr_CB_NOTIFY4args(XDR * xdrs, CB_NOTIFY4args * objp)
	{
		if (!xdr_stateid4(xdrs, &objp->cna_stateid))
			return false;
		if (!xdr_nfs_fh4(xdrs, &objp->cna_fh))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->cna_changes.cna_changes_val,
		     (u_int *) &objp->cna_changes.cna_changes_len, ~0,
		     sizeof(notify4), (xdrproc_t) xdr_notify4))
			return false;
		return true;
	}

	static inline bool xdr_CB_NOTIFY4res(XDR * xdrs, CB_NOTIFY4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->cnr_status))
			return false;
		return true;
	}

	static inline bool xdr_CB_PUSH_DELEG4args(XDR * xdrs,
						  CB_PUSH_DELEG4args * objp)
	{
		if (!xdr_nfs_fh4(xdrs, &objp->cpda_fh))
			return false;
		if (!xdr_open_delegation4(xdrs, &objp->cpda_delegation))
			return false;
		return true;
	}

	static inline bool xdr_CB_PUSH_DELEG4res(XDR * xdrs,
						 CB_PUSH_DELEG4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->cpdr_status))
			return false;
		return true;
	}

	static inline bool xdr_CB_RECALL_ANY4args(XDR * xdrs,
						  CB_RECALL_ANY4args * objp)
	{
		if (!inline_xdr_u_int32_t(xdrs, &objp->craa_objects_to_keep))
			return false;
		if (!xdr_bitmap4(xdrs, &objp->craa_type_mask))
			return false;
		return true;
	}

	static inline bool xdr_CB_RECALL_ANY4res(XDR * xdrs,
						 CB_RECALL_ANY4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->crar_status))
			return false;
		return true;
	}

	static inline bool xdr_CB_RECALLABLE_OBJ_AVAIL4args(
					XDR * xdrs,
					CB_RECALLABLE_OBJ_AVAIL4args * objp)
	{
		if (!xdr_CB_RECALL_ANY4args(xdrs, objp))
			return false;
		return true;
	}

	static inline bool xdr_CB_RECALLABLE_OBJ_AVAIL4res(
					XDR * xdrs,
					CB_RECALLABLE_OBJ_AVAIL4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->croa_status))
			return false;
		return true;
	}

	static inline bool xdr_CB_RECALL_SLOT4args(XDR * xdrs,
						   CB_RECALL_SLOT4args * objp)
	{
		if (!xdr_slotid4(xdrs, &objp->rsa_target_highest_slotid))
			return false;
		return true;
	}

	static inline bool xdr_CB_RECALL_SLOT4res(XDR * xdrs,
						  CB_RECALL_SLOT4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->rsr_status))
			return false;
		return true;
	}

	static inline bool xdr_referring_call4(XDR * xdrs,
					       referring_call4 * objp)
	{
		if (!xdr_sequenceid4(xdrs, &objp->rc_sequenceid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->rc_slotid))
			return false;
		return true;
	}

	static inline bool xdr_referring_call_list4(XDR * xdrs,
						    referring_call_list4 *
						    objp)
	{
		if (!xdr_sessionid4(xdrs, objp->rcl_sessionid))
			return false;
		if (!xdr_array
		    (xdrs,
		     (char **)&objp->rcl_referring_calls.
		     rcl_referring_calls_val,
		     (u_int *) &objp->rcl_referring_calls.
		     rcl_referring_calls_len, ~0, sizeof(referring_call4),
		     (xdrproc_t) xdr_referring_call4))
			return false;
		return true;
	}

	static inline bool xdr_CB_SEQUENCE4args(XDR * xdrs,
						CB_SEQUENCE4args * objp)
	{
		if (!xdr_sessionid4(xdrs, objp->csa_sessionid))
			return false;
		if (!xdr_sequenceid4(xdrs, &objp->csa_sequenceid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->csa_slotid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->csa_highest_slotid))
			return false;
		if (!inline_xdr_bool(xdrs, &objp->csa_cachethis))
			return false;
		if (!xdr_array
		    (xdrs,
		     (char **)&objp->csa_referring_call_lists.
		     csa_referring_call_lists_val,
		     (u_int *) &objp->csa_referring_call_lists.
		     csa_referring_call_lists_len, ~0,
		     sizeof(referring_call_list4),
		     (xdrproc_t) xdr_referring_call_list4))
			return false;
		return true;
	}

	static inline bool xdr_CB_SEQUENCE4resok(XDR * xdrs,
						 CB_SEQUENCE4resok * objp)
	{
		if (!xdr_sessionid4(xdrs, objp->csr_sessionid))
			return false;
		if (!xdr_sequenceid4(xdrs, &objp->csr_sequenceid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->csr_slotid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->csr_highest_slotid))
			return false;
		if (!xdr_slotid4(xdrs, &objp->csr_target_highest_slotid))
			return false;
		return true;
	}

	static inline bool xdr_CB_SEQUENCE4res(XDR * xdrs,
					       CB_SEQUENCE4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->csr_status))
			return false;
		switch (objp->csr_status) {
		case NFS4_OK:
			if (!xdr_CB_SEQUENCE4resok
			    (xdrs, &objp->CB_SEQUENCE4res_u.csr_resok4))
				return false;
			break;
		default:
			break;
		}
		return true;
	}

	static inline bool xdr_CB_WANTS_CANCELLED4args(XDR * xdrs,
						       CB_WANTS_CANCELLED4args *
						       objp)
	{
		if (!inline_xdr_bool
		    (xdrs, &objp->cwca_contended_wants_cancelled))
			return false;
		if (!inline_xdr_bool
		    (xdrs, &objp->cwca_resourced_wants_cancelled))
			return false;
		return true;
	}

	static inline bool xdr_CB_WANTS_CANCELLED4res(XDR * xdrs,
						      CB_WANTS_CANCELLED4res *
						      objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->cwcr_status))
			return false;
		return true;
	}

	static inline bool xdr_CB_NOTIFY_LOCK4args(XDR * xdrs,
						   CB_NOTIFY_LOCK4args * objp)
	{
		if (!xdr_nfs_fh4(xdrs, &objp->cnla_fh))
			return false;
		if (!xdr_lock_owner4(xdrs, &objp->cnla_lock_owner))
			return false;
		return true;
	}

	static inline bool xdr_CB_NOTIFY_LOCK4res(XDR * xdrs,
						  CB_NOTIFY_LOCK4res * objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->cnlr_status))
			return false;
		return true;
	}

	static inline bool xdr_notify_deviceid_type4(XDR * xdrs,
						     notify_deviceid_type4 *
						     objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_CB_NOTIFY_DEVICEID4args(XDR * xdrs,
						       CB_NOTIFY_DEVICEID4args *
						       objp)
	{
		if (!xdr_array
		    (xdrs, (char **)&objp->cnda_changes.cnda_changes_val,
		     (u_int *) &objp->cnda_changes.cnda_changes_len, ~0,
		     sizeof(notify4), (xdrproc_t) xdr_notify_dev))
			return false;
		return true;
	}

	static inline bool xdr_CB_NOTIFY_DEVICEID4res(XDR * xdrs,
						      CB_NOTIFY_DEVICEID4res *
						      objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->cndr_status))
			return false;
		return true;
	}

/* Callback operations new to NFSv4.1 */

	static inline bool xdr_nfs_cb_opnum4(XDR * xdrs, nfs_cb_opnum4 * objp)
	{
		if (!inline_xdr_enum(xdrs, (enum_t *) objp))
			return false;
		return true;
	}

	static inline bool xdr_nfs_cb_argop4(XDR * xdrs, nfs_cb_argop4 * objp)
	{
		if (!inline_xdr_u_int(xdrs, &objp->argop))
			return false;
		switch (objp->argop) {
		case NFS4_OP_CB_GETATTR:
			if (!xdr_CB_GETATTR4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbgetattr))
				return false;
			break;
		case NFS4_OP_CB_RECALL:
			if (!xdr_CB_RECALL4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbrecall))
				return false;
			break;
		case NFS4_OP_CB_LAYOUTRECALL:
			if (!xdr_CB_LAYOUTRECALL4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcblayoutrecall))
				return false;
			break;
		case NFS4_OP_CB_NOTIFY:
			if (!xdr_CB_NOTIFY4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbnotify))
				return false;
			break;
		case NFS4_OP_CB_PUSH_DELEG:
			if (!xdr_CB_PUSH_DELEG4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbpush_deleg))
				return false;
			break;
		case NFS4_OP_CB_RECALL_ANY:
			if (!xdr_CB_RECALL_ANY4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbrecall_any))
				return false;
			break;
		case NFS4_OP_CB_RECALLABLE_OBJ_AVAIL:
			if (!xdr_CB_RECALLABLE_OBJ_AVAIL4args
			    (xdrs,
			     &objp->nfs_cb_argop4_u.opcbrecallable_obj_avail))
				return false;
			break;
		case NFS4_OP_CB_RECALL_SLOT:
			if (!xdr_CB_RECALL_SLOT4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbrecall_slot))
				return false;
			break;
		case NFS4_OP_CB_SEQUENCE:
			if (!xdr_CB_SEQUENCE4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbsequence))
				return false;
			break;
		case NFS4_OP_CB_WANTS_CANCELLED:
			if (!xdr_CB_WANTS_CANCELLED4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbwants_cancelled))
				return false;
			break;
		case NFS4_OP_CB_NOTIFY_LOCK:
			if (!xdr_CB_NOTIFY_LOCK4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbnotify_lock))
				return false;
			break;
		case NFS4_OP_CB_NOTIFY_DEVICEID:
			if (!xdr_CB_NOTIFY_DEVICEID4args
			    (xdrs, &objp->nfs_cb_argop4_u.opcbnotify_deviceid))
				return false;
			break;
		case NFS4_OP_CB_ILLEGAL:
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_nfs_cb_resop4(XDR * xdrs, nfs_cb_resop4 * objp)
	{
		if (!inline_xdr_u_int(xdrs, &objp->resop))
			return false;
		switch (objp->resop) {
		case NFS4_OP_CB_GETATTR:
			if (!xdr_CB_GETATTR4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbgetattr))
				return false;
			break;
		case NFS4_OP_CB_RECALL:
			if (!xdr_CB_RECALL4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbrecall))
				return false;
			break;
		case NFS4_OP_CB_LAYOUTRECALL:
			if (!xdr_CB_LAYOUTRECALL4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcblayoutrecall))
				return false;
			break;
		case NFS4_OP_CB_NOTIFY:
			if (!xdr_CB_NOTIFY4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbnotify))
				return false;
			break;
		case NFS4_OP_CB_PUSH_DELEG:
			if (!xdr_CB_PUSH_DELEG4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbpush_deleg))
				return false;
			break;
		case NFS4_OP_CB_RECALL_ANY:
			if (!xdr_CB_RECALL_ANY4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbrecall_any))
				return false;
			break;
		case NFS4_OP_CB_RECALLABLE_OBJ_AVAIL:
			if (!xdr_CB_RECALLABLE_OBJ_AVAIL4res
			    (xdrs,
			     &objp->nfs_cb_resop4_u.opcbrecallable_obj_avail))
				return false;
			break;
		case NFS4_OP_CB_RECALL_SLOT:
			if (!xdr_CB_RECALL_SLOT4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbrecall_slot))
				return false;
			break;
		case NFS4_OP_CB_SEQUENCE:
			if (!xdr_CB_SEQUENCE4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbsequence))
				return false;
			break;
		case NFS4_OP_CB_WANTS_CANCELLED:
			if (!xdr_CB_WANTS_CANCELLED4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbwants_cancelled))
				return false;
			break;
		case NFS4_OP_CB_NOTIFY_LOCK:
			if (!xdr_CB_NOTIFY_LOCK4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbnotify_lock))
				return false;
			break;
		case NFS4_OP_CB_NOTIFY_DEVICEID:
			if (!xdr_CB_NOTIFY_DEVICEID4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbnotify_deviceid))
				return false;
			break;
		case NFS4_OP_CB_ILLEGAL:
			if (!xdr_CB_ILLEGAL4res
			    (xdrs, &objp->nfs_cb_resop4_u.opcbillegal))
				return false;
			break;
		default:
			return false;
		}
		return true;
	}

	static inline bool xdr_CB_COMPOUND4args(XDR * xdrs,
						CB_COMPOUND4args * objp)
	{
		if (!xdr_utf8str_cs(xdrs, &objp->tag))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->minorversion))
			return false;
		if (!inline_xdr_u_int32_t(xdrs, &objp->callback_ident))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->argarray.argarray_val,
		     (u_int *) &objp->argarray.argarray_len, ~0,
		     sizeof(nfs_cb_argop4), (xdrproc_t) xdr_nfs_cb_argop4))
			return false;
		return true;
	}

	static inline bool xdr_CB_COMPOUND4res(XDR * xdrs,
					       CB_COMPOUND4res *objp)
	{
		if (!xdr_nfsstat4(xdrs, &objp->status))
			return false;
		if (!xdr_utf8str_cs(xdrs, &objp->tag))
			return false;
		if (!xdr_array
		    (xdrs, (char **)&objp->resarray.resarray_val,
		     (u_int *) &objp->resarray.resarray_len, ~0,
		     sizeof(nfs_cb_resop4), (xdrproc_t) xdr_nfs_cb_resop4))
			return false;
		return true;
	}

	static inline bool xdr_nfs_ftype4();
	static inline bool xdr_nfsstat4();
	static inline bool xdr_attrlist4();
	static inline bool xdr_bitmap4();
	static inline bool xdr_changeid4();
	static inline bool xdr_clientid4();
	static inline bool xdr_count4();
	static inline bool xdr_length4();
	static inline bool xdr_mode4();
	static inline bool xdr_nfs_cookie4();
	static inline bool xdr_nfs_fh4();
	static inline bool xdr_offset4();
	static inline bool xdr_qop4();
	static inline bool xdr_sec_oid4();
	static inline bool xdr_sequenceid4();
	static inline bool xdr_seqid4();
	static inline bool xdr_sessionid4();
	static inline bool xdr_slotid4();
	static inline bool xdr_utf8string();
	static inline bool xdr_utf8str_cis();
	static inline bool xdr_utf8str_cs();
	static inline bool xdr_utf8str_mixed();
	static inline bool xdr_component4();
	static inline bool xdr_linktext4();
	static inline bool xdr_pathname4();
	static inline bool xdr_verifier4();
	static inline bool xdr_nfstime4();
	static inline bool xdr_time_how4();
	static inline bool xdr_settime4();
	static inline bool xdr_nfs_lease4();
	static inline bool xdr_fsid4();
	static inline bool xdr_change_policy4();
	static inline bool xdr_fs_location4();
	static inline bool xdr_fs_locations4();
	static inline bool xdr_acetype4();
	static inline bool xdr_aceflag4();
	static inline bool xdr_acemask4();
	static inline bool xdr_nfsace4();
	static inline bool xdr_aclflag4();
	static inline bool xdr_nfsacl41();
	static inline bool xdr_mode_masked4();
	static inline bool xdr_specdata4();
	static inline bool xdr_netaddr4();
	static inline bool xdr_nfs_impl_id4();
	static inline bool xdr_stateid4();
	static inline bool xdr_layouttype4();
	static inline bool xdr_layout_content4();
	static inline bool xdr_layouthint4();
	static inline bool xdr_layoutiomode4();
	static inline bool xdr_layout4();
	static inline bool xdr_deviceid4();
	static inline bool xdr_device_addr4();
	static inline bool xdr_layoutupdate4();
	static inline bool xdr_layoutreturn_type4();
	static inline bool xdr_layoutreturn_file4();
	static inline bool xdr_layoutreturn4();
	static inline bool xdr_fs4_status_type();
	static inline bool xdr_fs4_status();
	static inline bool xdr_threshold4_read_size();
	static inline bool xdr_threshold4_write_size();
	static inline bool xdr_threshold4_read_iosize();
	static inline bool xdr_threshold4_write_iosize();
	static inline bool xdr_threshold_item4();
	static inline bool xdr_mdsthreshold4();
	static inline bool xdr_retention_get4();
	static inline bool xdr_retention_set4();
	static inline bool xdr_fs_charset_cap4();
	static inline bool xdr_fattr4_supported_attrs();
	static inline bool xdr_fattr4_type();
	static inline bool xdr_fattr4_fh_expire_type();
	static inline bool xdr_fattr4_change();
	static inline bool xdr_fattr4_size();
	static inline bool xdr_fattr4_link_support();
	static inline bool xdr_fattr4_symlink_support();
	static inline bool xdr_fattr4_named_attr();
	static inline bool xdr_fattr4_fsid();
	static inline bool xdr_fattr4_unique_handles();
	static inline bool xdr_fattr4_lease_time();
	static inline bool xdr_fattr4_rdattr_error();
	static inline bool xdr_fattr4_acl();
	static inline bool xdr_fattr4_aclsupport();
	static inline bool xdr_fattr4_archive();
	static inline bool xdr_fattr4_cansettime();
	static inline bool xdr_fattr4_case_insensitive();
	static inline bool xdr_fattr4_case_preserving();
	static inline bool xdr_fattr4_chown_restricted();
	static inline bool xdr_fattr4_fileid();
	static inline bool xdr_fattr4_files_avail();
	static inline bool xdr_fattr4_filehandle();
	static inline bool xdr_fattr4_files_free();
	static inline bool xdr_fattr4_files_total();
	static inline bool xdr_fattr4_fs_locations();
	static inline bool xdr_fattr4_hidden();
	static inline bool xdr_fattr4_homogeneous();
	static inline bool xdr_fattr4_maxfilesize();
	static inline bool xdr_fattr4_maxlink();
	static inline bool xdr_fattr4_maxname();
	static inline bool xdr_fattr4_maxread();
	static inline bool xdr_fattr4_maxwrite();
	static inline bool xdr_fattr4_mimetype();
	static inline bool xdr_fattr4_mode();
	static inline bool xdr_fattr4_mode_set_masked();
	static inline bool xdr_fattr4_mounted_on_fileid();
	static inline bool xdr_fattr4_no_trunc();
	static inline bool xdr_fattr4_numlinks();
	static inline bool xdr_fattr4_owner();
	static inline bool xdr_fattr4_owner_group();
	static inline bool xdr_fattr4_quota_avail_hard();
	static inline bool xdr_fattr4_quota_avail_soft();
	static inline bool xdr_fattr4_quota_used();
	static inline bool xdr_fattr4_rawdev();
	static inline bool xdr_fattr4_space_avail();
	static inline bool xdr_fattr4_space_free();
	static inline bool xdr_fattr4_space_total();
	static inline bool xdr_fattr4_space_used();
	static inline bool xdr_fattr4_system();
	static inline bool xdr_fattr4_time_access();
	static inline bool xdr_fattr4_time_access_set();
	static inline bool xdr_fattr4_time_backup();
	static inline bool xdr_fattr4_time_create();
	static inline bool xdr_fattr4_time_delta();
	static inline bool xdr_fattr4_time_metadata();
	static inline bool xdr_fattr4_time_modify();
	static inline bool xdr_fattr4_time_modify_set();
	static inline bool xdr_fattr4_suppattr_exclcreat();
	static inline bool xdr_fattr4_dir_notif_delay();
	static inline bool xdr_fattr4_dirent_notif_delay();
	static inline bool xdr_fattr4_fs_layout_types();
	static inline bool xdr_fattr4_fs_status();
	static inline bool xdr_fattr4_fs_charset_cap();
	static inline bool xdr_fattr4_layout_alignment();
	static inline bool xdr_fattr4_layout_blksize();
	static inline bool xdr_fattr4_layout_hint();
	static inline bool xdr_fattr4_layout_types();
	static inline bool xdr_fattr4_mdsthreshold();
	static inline bool xdr_fattr4_retention_get();
	static inline bool xdr_fattr4_retention_set();
	static inline bool xdr_fattr4_retentevt_get();
	static inline bool xdr_fattr4_retentevt_set();
	static inline bool xdr_fattr4_retention_hold();
	static inline bool xdr_fattr4_dacl();
	static inline bool xdr_fattr4_sacl();
	static inline bool xdr_fattr4_change_policy();
	static inline bool xdr_fattr4();
	static inline bool xdr_change_info4();
	static inline bool xdr_clientaddr4();
	static inline bool xdr_cb_client4();
	static inline bool xdr_nfs_client_id4();
	static inline bool xdr_client_owner4();
	static inline bool xdr_server_owner4();
	static inline bool xdr_state_owner4();
	static inline bool xdr_open_owner4();
	static inline bool xdr_lock_owner4();
	static inline bool xdr_nfs_lock_type4();
	static inline bool xdr_ssv_subkey4();
	static inline bool xdr_ssv_mic_plain_tkn4();
	static inline bool xdr_ssv_mic_tkn4();
	static inline bool xdr_ssv_seal_plain_tkn4();
	static inline bool xdr_ssv_seal_cipher_tkn4();
	static inline bool xdr_fs_locations_server4();
	static inline bool xdr_fs_locations_item4();
	static inline bool xdr_fs_locations_info4();
	static inline bool xdr_fattr4_fs_locations_info();
	static inline bool xdr_nfl_util4();
	static inline bool xdr_filelayout_hint_care4();
	static inline bool xdr_nfsv4_1_file_layouthint4();
	static inline bool xdr_multipath_list4();
	static inline bool xdr_nfsv4_1_file_layout_ds_addr4();
	static inline bool xdr_nfsv4_1_file_layout4();
	static inline bool xdr_ACCESS4args();
	static inline bool xdr_ACCESS4resok();
	static inline bool xdr_ACCESS4res();
	static inline bool xdr_CLOSE4args();
	static inline bool xdr_CLOSE4res();
	static inline bool xdr_COMMIT4args();
	static inline bool xdr_COMMIT4resok();
	static inline bool xdr_COMMIT4res();
	static inline bool xdr_createtype4();
	static inline bool xdr_CREATE4args();
	static inline bool xdr_CREATE4resok();
	static inline bool xdr_CREATE4res();
	static inline bool xdr_DELEGPURGE4args();
	static inline bool xdr_DELEGPURGE4res();
	static inline bool xdr_DELEGRETURN4args();
	static inline bool xdr_DELEGRETURN4res();
	static inline bool xdr_GETATTR4args();
	static inline bool xdr_GETATTR4resok();
	static inline bool xdr_GETATTR4res();
	static inline bool xdr_GETFH4resok();
	static inline bool xdr_GETFH4res();
	static inline bool xdr_LINK4args();
	static inline bool xdr_LINK4resok();
	static inline bool xdr_LINK4res();
	static inline bool xdr_open_to_lock_owner4();
	static inline bool xdr_exist_lock_owner4();
	static inline bool xdr_locker4();
	static inline bool xdr_LOCK4args();
	static inline bool xdr_LOCK4denied();
	static inline bool xdr_LOCK4resok();
	static inline bool xdr_LOCK4res();
	static inline bool xdr_LOCKT4args();
	static inline bool xdr_LOCKT4res();
	static inline bool xdr_LOCKU4args();
	static inline bool xdr_LOCKU4res();
	static inline bool xdr_LOOKUP4args();
	static inline bool xdr_LOOKUP4res();
	static inline bool xdr_LOOKUPP4res();
	static inline bool xdr_NVERIFY4args();
	static inline bool xdr_NVERIFY4res();
	static inline bool xdr_createmode4();
	static inline bool xdr_creatverfattr();
	static inline bool xdr_createhow4();
	static inline bool xdr_opentype4();
	static inline bool xdr_openflag4();
	static inline bool xdr_limit_by4();
	static inline bool xdr_nfs_modified_limit4();
	static inline bool xdr_nfs_space_limit4();
	static inline bool xdr_open_delegation_type4();
	static inline bool xdr_open_claim_type4();
	static inline bool xdr_open_claim_delegate_cur4();
	static inline bool xdr_open_claim4();
	static inline bool xdr_OPEN4args();
	static inline bool xdr_open_read_delegation4();
	static inline bool xdr_open_write_delegation4();
	static inline bool xdr_why_no_delegation4();
	static inline bool xdr_open_none_delegation4();
	static inline bool xdr_open_delegation4();
	static inline bool xdr_OPEN4resok();
	static inline bool xdr_OPEN4res();
	static inline bool xdr_OPENATTR4args();
	static inline bool xdr_OPENATTR4res();
	static inline bool xdr_OPEN_CONFIRM4args();
	static inline bool xdr_OPEN_CONFIRM4resok();
	static inline bool xdr_OPEN_CONFIRM4res();
	static inline bool xdr_OPEN_DOWNGRADE4args();
	static inline bool xdr_OPEN_DOWNGRADE4resok();
	static inline bool xdr_OPEN_DOWNGRADE4res();
	static inline bool xdr_PUTFH4args();
	static inline bool xdr_PUTFH4res();
	static inline bool xdr_PUTPUBFH4res();
	static inline bool xdr_PUTROOTFH4res();
	static inline bool xdr_READ4args();
	static inline bool xdr_READ4resok();
	static inline bool xdr_READ4res();
	static inline bool xdr_READDIR4args();
	static inline bool xdr_entry4();
	static inline bool xdr_dirlist4();
	static inline bool xdr_READDIR4resok();
	static inline bool xdr_READDIR4res();
	static inline bool xdr_READLINK4resok();
	static inline bool xdr_READLINK4res();
	static inline bool xdr_REMOVE4args();
	static inline bool xdr_REMOVE4resok();
	static inline bool xdr_REMOVE4res();
	static inline bool xdr_RENAME4args();
	static inline bool xdr_RENAME4resok();
	static inline bool xdr_RENAME4res();
	static inline bool xdr_RENEW4args();
	static inline bool xdr_RENEW4res();
	static inline bool xdr_RESTOREFH4res();
	static inline bool xdr_SAVEFH4res();
	static inline bool xdr_SECINFO4args();
	static inline bool xdr_rpc_gss_svc_t();
	static inline bool xdr_rpcsec_gss_info();
	static inline bool xdr_secinfo4();
	static inline bool xdr_SECINFO4resok();
	static inline bool xdr_SECINFO4res();
	static inline bool xdr_SETATTR4args();
	static inline bool xdr_SETATTR4res();
	static inline bool xdr_SETCLIENTID4args();
	static inline bool xdr_SETCLIENTID4resok();
	static inline bool xdr_SETCLIENTID4res();
	static inline bool xdr_SETCLIENTID_CONFIRM4args();
	static inline bool xdr_SETCLIENTID_CONFIRM4res();
	static inline bool xdr_VERIFY4args();
	static inline bool xdr_VERIFY4res();
	static inline bool xdr_stable_how4();
	static inline bool xdr_WRITE4args();
	static inline bool xdr_WRITE4resok();
	static inline bool xdr_WRITE4res();
	static inline bool xdr_RELEASE_LOCKOWNER4args();
	static inline bool xdr_RELEASE_LOCKOWNER4res();
	static inline bool xdr_ILLEGAL4res();
	static inline bool xdr_gsshandle4_t();
	static inline bool xdr_gss_cb_handles4();
	static inline bool xdr_callback_sec_parms4();
	static inline bool xdr_BACKCHANNEL_CTL4args();
	static inline bool xdr_BACKCHANNEL_CTL4res();
	static inline bool xdr_channel_dir_from_client4();
	static inline bool xdr_BIND_CONN_TO_SESSION4args();
	static inline bool xdr_channel_dir_from_server4();
	static inline bool xdr_BIND_CONN_TO_SESSION4resok();
	static inline bool xdr_BIND_CONN_TO_SESSION4res();
	static inline bool xdr_state_protect_ops4();
	static inline bool xdr_ssv_sp_parms4();
	static inline bool xdr_state_protect_how4();
	static inline bool xdr_state_protect4_a();
	static inline bool xdr_EXCHANGE_ID4args();
	static inline bool xdr_ssv_prot_info4();
	static inline bool xdr_state_protect4_r();
	static inline bool xdr_EXCHANGE_ID4resok();
	static inline bool xdr_EXCHANGE_ID4res();
	static inline bool xdr_channel_attrs4();
	static inline bool xdr_CREATE_SESSION4args();
	static inline bool xdr_CREATE_SESSION4resok();
	static inline bool xdr_CREATE_SESSION4res();
	static inline bool xdr_DESTROY_SESSION4args();
	static inline bool xdr_DESTROY_SESSION4res();
	static inline bool xdr_FREE_STATEID4args();
	static inline bool xdr_FREE_STATEID4res();
	static inline bool xdr_attr_notice4();
	static inline bool xdr_GET_DIR_DELEGATION4args();
	static inline bool xdr_GET_DIR_DELEGATION4resok();
	static inline bool xdr_gddrnf4_status();
	static inline bool xdr_GET_DIR_DELEGATION4res_non_fatal();
	static inline bool xdr_GET_DIR_DELEGATION4res();
	static inline bool xdr_GETDEVICEINFO4args();
	static inline bool xdr_GETDEVICEINFO4resok();
	static inline bool xdr_GETDEVICEINFO4res();
	static inline bool xdr_GETDEVICELIST4args();
	static inline bool xdr_GETDEVICELIST4resok();
	static inline bool xdr_GETDEVICELIST4res();
	static inline bool xdr_newtime4();
	static inline bool xdr_newoffset4();
	static inline bool xdr_LAYOUTCOMMIT4args();
	static inline bool xdr_newsize4();
	static inline bool xdr_LAYOUTCOMMIT4resok();
	static inline bool xdr_LAYOUTCOMMIT4res();
	static inline bool xdr_LAYOUTGET4args();
	static inline bool xdr_LAYOUTGET4resok();
	static inline bool xdr_LAYOUTGET4res();
	static inline bool xdr_LAYOUTRETURN4args();
	static inline bool xdr_layoutreturn_stateid();
	static inline bool xdr_LAYOUTRETURN4res();
	static inline bool xdr_secinfo_style4();
	static inline bool xdr_SECINFO_NO_NAME4args();
	static inline bool xdr_SECINFO_NO_NAME4res();
	static inline bool xdr_SEQUENCE4args();
	static inline bool xdr_SEQUENCE4resok();
	static inline bool xdr_SEQUENCE4res();
	static inline bool xdr_ssa_digest_input4();
	static inline bool xdr_SET_SSV4args();
	static inline bool xdr_ssr_digest_input4();
	static inline bool xdr_SET_SSV4resok();
	static inline bool xdr_SET_SSV4res();
	static inline bool xdr_TEST_STATEID4args();
	static inline bool xdr_TEST_STATEID4resok();
	static inline bool xdr_TEST_STATEID4res();
	static inline bool xdr_deleg_claim4();
	static inline bool xdr_WANT_DELEGATION4args();
	static inline bool xdr_WANT_DELEGATION4res();
	static inline bool xdr_DESTROY_CLIENTID4args();
	static inline bool xdr_DESTROY_CLIENTID4res();
	static inline bool xdr_RECLAIM_COMPLETE4args();
	static inline bool xdr_RECLAIM_COMPLETE4res();
	static inline bool xdr_nfs_opnum4();
	static inline bool xdr_nfs_argop4();
	static inline bool xdr_nfs_resop4();
	static inline bool xdr_COMPOUND4args();
	static inline bool xdr_COMPOUND4res();
	static inline bool xdr_CB_GETATTR4args();
	static inline bool xdr_CB_GETATTR4resok();
	static inline bool xdr_CB_GETATTR4res();
	static inline bool xdr_CB_RECALL4args();
	static inline bool xdr_CB_RECALL4res();
	static inline bool xdr_CB_ILLEGAL4res();
	static inline bool xdr_layoutrecall_type4();
	static inline bool xdr_layoutrecall_file4();
	static inline bool xdr_layoutrecall4();
	static inline bool xdr_CB_LAYOUTRECALL4args();
	static inline bool xdr_CB_LAYOUTRECALL4res();
	static inline bool xdr_notify_type4();
	static inline bool xdr_notify_entry4();
	static inline bool xdr_prev_entry4();
	static inline bool xdr_notify_remove4();
	static inline bool xdr_notify_add4();
	static inline bool xdr_notify_attr4();
	static inline bool xdr_notify_rename4();
	static inline bool xdr_notify_verifier4();
	static inline bool xdr_notifylist4();
	static inline bool xdr_notify4();
	static inline bool xdr_CB_NOTIFY4args();
	static inline bool xdr_CB_NOTIFY4res();
	static inline bool xdr_CB_PUSH_DELEG4args();
	static inline bool xdr_CB_PUSH_DELEG4res();
	static inline bool xdr_CB_RECALL_ANY4args();
	static inline bool xdr_CB_RECALL_ANY4res();
	static inline bool xdr_CB_RECALLABLE_OBJ_AVAIL4args();
	static inline bool xdr_CB_RECALLABLE_OBJ_AVAIL4res();
	static inline bool xdr_CB_RECALL_SLOT4args();
	static inline bool xdr_CB_RECALL_SLOT4res();
	static inline bool xdr_referring_call4();
	static inline bool xdr_referring_call_list4();
	static inline bool xdr_CB_SEQUENCE4args();
	static inline bool xdr_CB_SEQUENCE4resok();
	static inline bool xdr_CB_SEQUENCE4res();
	static inline bool xdr_CB_WANTS_CANCELLED4args();
	static inline bool xdr_CB_WANTS_CANCELLED4res();
	static inline bool xdr_CB_NOTIFY_LOCK4args();
	static inline bool xdr_CB_NOTIFY_LOCK4res();
	static inline bool xdr_notify_deviceid_type4();
	static inline bool xdr_notify_deviceid_delete4();
	static inline bool xdr_notify_deviceid_change4();
	static inline bool xdr_CB_NOTIFY_DEVICEID4args();
	static inline bool xdr_CB_NOTIFY_DEVICEID4res();
	static inline bool xdr_nfs_cb_opnum4();
	static inline bool xdr_nfs_cb_argop4();
	static inline bool xdr_nfs_cb_resop4();
	static inline bool xdr_CB_COMPOUND4args();
	static inline bool xdr_CB_COMPOUND4res();

#endif				/* K&R C */

#ifdef __cplusplus
}
#endif

#endif				/* !_GSH_NFSV41_XDR_H_RPCGEN */
