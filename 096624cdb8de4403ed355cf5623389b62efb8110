{
  "comments": [
    {
      "key": {
        "uuid": "0f29cc69_74beadfb",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c",
        "patchSetId": 1
      },
      "lineNbr": 823,
      "author": {
        "id": 1004087
      },
      "writtenOn": "2020-02-10T15:10:30Z",
      "side": 1,
      "message": "I don\u0027t think the content lock protects against deleting the entry.  It\u0027s not taken anywhere in the unref path, so this entry can be freed from under us while we\u0027re using it.  I think we really need to have a ref here, so some other solution to the 0-\u003e1 problem is necessary.  Maybe check to see if we went from 0 to 1 and bail if we did?",
      "revId": "096624cdb8de4403ed355cf5623389b62efb8110",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3dcb2dd3_df7b2510",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c",
        "patchSetId": 1
      },
      "lineNbr": 823,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2020-02-10T17:33:41Z",
      "side": 1,
      "message": "Yea, that should work. The atomic increment functions return the count as a result of that increment so you can look for this. One thing to check for, are there any other ways to try and take an inode reference using a pointer from some other object that could race (so the 2nd thread increments from 1 to 2 and doesn\u0027t detect this special condition).",
      "parentUuid": "0f29cc69_74beadfb",
      "revId": "096624cdb8de4403ed355cf5623389b62efb8110",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}