{
  "comments": [
    {
      "key": {
        "uuid": "0f29cc69_74beadfb",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c",
        "patchSetId": 1
      },
      "lineNbr": 823,
      "author": {
        "id": 1004087
      },
      "writtenOn": "2020-02-10T15:10:30Z",
      "side": 1,
      "message": "I don\u0027t think the content lock protects against deleting the entry.  It\u0027s not taken anywhere in the unref path, so this entry can be freed from under us while we\u0027re using it.  I think we really need to have a ref here, so some other solution to the 0-\u003e1 problem is necessary.  Maybe check to see if we went from 0 to 1 and bail if we did?",
      "revId": "096624cdb8de4403ed355cf5623389b62efb8110",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3dcb2dd3_df7b2510",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c",
        "patchSetId": 1
      },
      "lineNbr": 823,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2020-02-10T17:33:41Z",
      "side": 1,
      "message": "Yea, that should work. The atomic increment functions return the count as a result of that increment so you can look for this. One thing to check for, are there any other ways to try and take an inode reference using a pointer from some other object that could race (so the 2nd thread increments from 1 to 2 and doesn\u0027t detect this special condition).",
      "parentUuid": "0f29cc69_74beadfb",
      "revId": "096624cdb8de4403ed355cf5623389b62efb8110",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "750a808f_29db58c2",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c",
        "patchSetId": 1
      },
      "lineNbr": 823,
      "author": {
        "id": 1003947
      },
      "writtenOn": "2020-02-11T12:20:09Z",
      "side": 1,
      "message": "The chunk reaper code takes QLANE lock followed by content lock. The unref path does take the content_lock for a directory (followed by QLANE lock) while cleaning up its chunks. So what is said in the commit is true for directory objects.\n\nFrank/Dan, initially I tried checking for refcnt and directly decrementing if the refcnt was zero (comparision to 1) and call mdcache_put() otherwise (same as the existing code). This won\u0027t work as Frank noticed because two threads doing chunk reaping could increment at the same time leading to one chunk reaping thread racing with another request thread (like rmdir) that actually was trying to free the entry.  We did a similar check with other hash implementations to prevent 0-\u003e1 issue but that is done under a lock (hashtable lock). So a lock in chunk reap function while doing atomic incr/dec will work but that is unnecessary as I said for directories. I do need a comment in the code to explain it  better.",
      "parentUuid": "3dcb2dd3_df7b2510",
      "revId": "096624cdb8de4403ed355cf5623389b62efb8110",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}