{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bc442c63_fa3118d2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2021-05-17T15:00:38Z",
      "side": 1,
      "message": "Could you add more explanation to the commit message.\n\nI think this is OK, but I am worried about some side effects:\n\n1. If a client has some old unpadded handles cached, a new handle for the same file will not match, possibly confusing the clients.\n\n2. When PROXY is used to proxy a Ganeaha server, the increase in handle size due to padding could possibly cause an overflow of the maximum handle size when previously it was fine. Note that the padding presumably generally adds 3 bytes to the handle since the Ganesha header is 5 bytes and often the opaque part of the handle is a multiple of 4 bytes.\n\nThis may be something that should be a configurable option to avoid the unintended consequences when the need is not there.",
      "revId": "d45ffa051d31b83a9cba68d2531eaa44f503757d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "02b74bd9_b6e6d466",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1017959
      },
      "writtenOn": "2021-05-20T20:29:01Z",
      "side": 1,
      "message": "we are handling both new and old file handles , we check for unpadded file handle size and handle them gracefully. If client sends cached old FH, we call nfs4_sizeof_handle_nopadding( and accept it.\nIsn\u0027t the same problem exists already for NFSv3  which  only supports 64 bytes ?  NFSv4 supports 128 byte FH.\n\nAFM stores file handles as part of inode and uses them for replication. For example, if there is a write to existing file, AFM uses VFS interface to convert  stored file handle to dentry and then dentry is opened for the writing.  This is to support existing AFM filesets which stored NFSv3 file handles  to work with  NFSv4 mount. kNFS already supports this and does not change file handle size between v3 and v4. For ganesha , file handle size is changed causing the existing filesets not to work with NFSv4 support.",
      "parentUuid": "bc442c63_fa3118d2",
      "revId": "d45ffa051d31b83a9cba68d2531eaa44f503757d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d6fd13ae_46389c71",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2021-05-21T22:51:12Z",
      "side": 1,
      "message": "So one of my concerns is a plain old Linux client that has cached a handle for some file. Then it does a lookup for a different link to the same file and gets the new handle. How is the client going to deal with having two different handles for what is ultimately the same inode (and the client will know the fsid and fileid match). Or what happens when a READDIR returns new handles?\n\nAnd then for those who might be using FSAL_PROXY (V3 or V4), what kind of impact is there? MDCACHE will cache the object as a separate object, and there\u0027s also the possibility the increased handle size causes some kind of problem with being able to wrap the proxied handle and still fit, especially for V3.\n\nThat\u0027s why I wonder if this should be a configurable behavior.",
      "parentUuid": "02b74bd9_b6e6d466",
      "revId": "d45ffa051d31b83a9cba68d2531eaa44f503757d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}