{
  "comments": [
    {
      "key": {
        "uuid": "f9a976ce_cd751542",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_export.c",
        "patchSetId": 8
      },
      "lineNbr": 172,
      "author": {
        "id": 1016888
      },
      "writtenOn": "2020-06-04T11:54:05Z",
      "side": 1,
      "message": "If an object to be root of multiple exports, here should not release the sentinel reference and set entry as invalid when the first export unmount, but occur in the last export release.",
      "range": {
        "startLine": 172,
        "startChar": 1,
        "endLine": 172,
        "endChar": 45
      },
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b718acbb_b8643c1e",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_export.c",
        "patchSetId": 8
      },
      "lineNbr": 172,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2020-06-04T15:43:58Z",
      "side": 1,
      "message": "This is a good catch, I actually saw this yesterday, I\u0027m not sure this really is the right fix, let\u0027s leave this bit out of this patch. Even if this is the right fix, I\u0027d rather it be in a separate patch. I will also be testing in this area.\n\nI think actually the loop above should take care of the root entry of an export. I\u0027ll resolve this with the work I\u0027m doing on export update/add/remove.",
      "parentUuid": "f9a976ce_cd751542",
      "range": {
        "startLine": 172,
        "startChar": 1,
        "endLine": 172,
        "endChar": 45
      },
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b09ea99_f9103d82",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_export.c",
        "patchSetId": 8
      },
      "lineNbr": 172,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2020-06-04T21:45:08Z",
      "side": 1,
      "message": "Ok, in fact, if the entry is no longer the root of any export, it WILL have been unhashed above by mdcache_lru_cleanup_try_push (in which case cih_remove_checked does nothing, and in fact, this is pretty much guaranteed... the assert looks for a false return from cih_remove_checked which means it does nothing, in fact, basically the assertion asserts that cih_remove_checked is not necessary! So in fact, if an entry ever was the root of more than one export, the assert should fail...\n\nI will be removing this call to cih_remove_checked in my patches.\n\nI think the code that added this call to cih_remove_checked actually fixed the issue it was expecting to fix by other parts of the change.",
      "parentUuid": "b718acbb_b8643c1e",
      "range": {
        "startLine": 172,
        "startChar": 1,
        "endLine": 172,
        "endChar": 45
      },
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "270bdd0c_e77a447a",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_export.c",
        "patchSetId": 8
      },
      "lineNbr": 172,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2020-06-04T22:21:56Z",
      "side": 1,
      "message": "Oops, I was looking at the wrong function... This uses cih_remove_checked which only returns true if mdcache_lru_unref frees the entry, which will never happen because our caller always has a reference.\n\nI actually tried to break things, I created two exports of the same path but different pseudo and tag and then unexported the first, it did unhash the entry, but try as I might, I couldn\u0027t actually break anything because of that... At some point though, a client will try and use the handle and something will go not right because it can\u0027t find the handle in the hash table any more. With some added debug I can definitely see this unhashing when it shouldn\u0027t, but because the existence of an export on the inode, the entry itself is safe until that export is unexported.\n\nIn any case, this call to cih_remove_checked is NOT necessary, and won\u0027t do anything in the case of a single export using the node.",
      "parentUuid": "7b09ea99_f9103d82",
      "range": {
        "startLine": 172,
        "startChar": 1,
        "endLine": 172,
        "endChar": 45
      },
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84809adf_c399053a",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_export.c",
        "patchSetId": 8
      },
      "lineNbr": 172,
      "author": {
        "id": 1016888
      },
      "writtenOn": "2020-06-05T10:13:45Z",
      "side": 1,
      "message": "Yes, I agree that make a separate patch here. The reason I modified it in this patch isï¼š\nI create two exports of the same path(root_object), when remove one of the export(such as export1) by dbus, here will release the sentinel reference and set root entry as invalid, in the end, there is only reference count in root object and its cache status is invalid, but it exists LRU lane. This will lead to the object to fail both of entry recycle and release,mainly block in LRU of lru lane and prevents the next entries from being released.\nBesides, I think release the sentinel reference should occur in the last export release not first.\nShould I keep this modification? At least for now, the entry release function can be guaranteed.",
      "parentUuid": "270bdd0c_e77a447a",
      "range": {
        "startLine": 172,
        "startChar": 1,
        "endLine": 172,
        "endChar": 45
      },
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77191f98_7903c7a0",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_helpers.c",
        "patchSetId": 8
      },
      "lineNbr": 187,
      "author": {
        "id": 1004075
      },
      "writtenOn": "2020-06-04T14:02:30Z",
      "side": 1,
      "message": "this seems like a good idea",
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "483c7e69_45a9279e",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c",
        "patchSetId": 8
      },
      "lineNbr": 722,
      "author": {
        "id": 1004075
      },
      "writtenOn": "2020-06-04T14:02:30Z",
      "side": 1,
      "message": "as before, this doesn\u0027t look right to me;  as I think Frank proposed, let\u0027s mark or otherwise make \"rootness\" explicit",
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "690dac1b_cee66c4c",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c",
        "patchSetId": 8
      },
      "lineNbr": 722,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2020-06-04T15:43:58Z",
      "side": 1,
      "message": "Matt, I\u0027m not quite sure what you are concerned about.\n\nIt might be more clear if adjust_lru_root_object was just straight coded here though.",
      "parentUuid": "483c7e69_45a9279e",
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "925679d3_1ba57d29",
        "filename": "src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c",
        "patchSetId": 8
      },
      "lineNbr": 2002,
      "author": {
        "id": 1004075
      },
      "writtenOn": "2020-06-04T14:02:30Z",
      "side": 1,
      "message": "this is a nice cleanup",
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "66efbcfc_8f334485",
        "filename": "src/Protocols/NFS/nfs4_pseudo.c",
        "patchSetId": 8
      },
      "lineNbr": 219,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2020-06-04T15:43:58Z",
      "side": 1,
      "message": "You shouldn\u0027t need this (and you don\u0027t have a matching put when pseudofs entries are deleted). PseudoFS entries that are not junctions should be able to be released from mdcache, FSAL_PSEUDO keeps track of them and create_handle will revive them into mdcache.",
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4036cf30_0e82d4a5",
        "filename": "src/Protocols/NFS/nfs4_pseudo.c",
        "patchSetId": 8
      },
      "lineNbr": 219,
      "author": {
        "id": 1016888
      },
      "writtenOn": "2020-06-05T10:13:45Z",
      "side": 1,
      "message": "I don\u0027t understand why it\u0027s shouldn\u0027t need here as you said, make_pseudofs_node either already exists in sub_FSAL or create in PseudoFS, but in either case, the object will be referenced by PseudoFS export, so I think it needs to be mark(export_root_object_put) here as well. Both above cases can match export_root_object_put in pseudo_unmount_export.\nIt would be more appropriate to modify it into pseudo_mount_export().",
      "parentUuid": "66efbcfc_8f334485",
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "413f549c_5fd94db7",
        "filename": "src/include/fsal_api.h",
        "patchSetId": 8
      },
      "lineNbr": 2921,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2020-06-04T15:43:58Z",
      "side": 1,
      "message": "This just needs to count root nodes and junction nodes, it doesn\u0027t need to count pseudofs nodes",
      "revId": "b13910a99a6a63dd8f44685c936078aeda048562",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}