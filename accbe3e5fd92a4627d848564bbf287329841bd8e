{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "dec677b8_67001447",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1004087
      },
      "writtenOn": "2024-08-12T13:03:21Z",
      "side": 1,
      "message": "Is there a problem with just LD_PRELOAD?",
      "revId": "accbe3e5fd92a4627d848564bbf287329841bd8e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f54a9f04_9891a30b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1020671
      },
      "writtenOn": "2024-08-13T15:24:27Z",
      "side": 1,
      "message": "Yes, I ran it at first in our production with LD_PRELOAD and it failed in a rare race case. \nBasically, the problem is that it doesn\u0027t work with fork. What happens is that LD_PRELOAD runs some code in parallel to ganesha main (I don\u0027t fully understand the details) and then ganehsa main forks. There was a rare (but not that rare) case that the fork happened while the LD_PRELOAD held a global mutex for ld_load. The fork duplicates memory to the child, so in the child this lock is marked as held, but there is no process to release it, in the future whenever this lock was taken (on future dl_open in ganesha) we got a deadlock. \n\nButtom line is that LD_PRELOAD doesn\u0027t work well with fork, and this is a cleaner way to load .so.",
      "parentUuid": "dec677b8_67001447",
      "revId": "accbe3e5fd92a4627d848564bbf287329841bd8e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}