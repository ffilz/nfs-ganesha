{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "19ae524d_96437097",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2022-06-08T19:32:01Z",
      "side": 1,
      "message": "What is the full stack of this?",
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ca9c10b_03be8329",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1015367
      },
      "writtenOn": "2022-06-09T08:51:53Z",
      "side": 1,
      "message": "This is asan log, \n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\u003d\u003d205902\u003d\u003d ERROR: AddressSanitizer: heap-use-after-free on address 0x600c00436340 at pc 0x7f542f69f554 bp 0x7f5421787780 sp 0x7f5421787770\nREAD of size 8 at 0x600c00436340 thread T1\n#0 0x7f542f69f553 in posix2fsal_attributes /usr/include/urcu/ref.h:85\n#1 0x7f542f69f872 in posix2fsal_attributes /usr/src/debug/nfs-ganesha-4.0.2/include/gsh_refstr.h:96\n#2 0x7f542f6ad974 in fsal_common_is_referral /usr/src/debug/nfs-ganesha-4.0.2/FSAL/commonlib.c:2004 \u003d\u003d\u003e(ignore fsal_common_is_referral, it should be set_op_context_export_fsal_no_release at this location)\n#3 0x7f542f6aee2a in init_op_context /usr/src/debug/nfs-ganesha-4.0.2/FSAL/commonlib.c:2166\n#4 0x7f542f846c02 in init_op_context_simple /usr/src/debug/nfs-ganesha-4.0.2/include/fsal.h:124\n#5 0x7f542f84b0e0 in lru_run_lane /usr/src/debug/nfs-ganesha-4.0.2/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c:1197\n#6 0x7f542f84be34 in lru_run /usr/src/debug/nfs-ganesha-4.0.2/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_lru.c:1425\n#7 0x7f542f7a6daf in fridgethr_start_routine /usr/src/debug/nfs-ganesha-4.0.2/support/fridgethr.c:556\n#8 0x7f542fb69a87 in __asan_describe_address ??:?\n#9 0x7f542db68ea4 in start_thread pthread_create.c:?\n#10 0x7f542d46fb0c in __clone ??:?\n0x600c00436340 is located 0 bytes inside of 54-byte region [0x600c00436340,0x600c00436376)\nfreed by thread T24 here:\n#0 0x7f542fb65ff9 in __interceptor_free ??:?\n#1 0x7f542f7c1a38 in gsh_free /usr/src/debug/nfs-ganesha-4.0.2/include/abstract_mem.h:256\n#2 0x7f542f7c1b01 in gsh_refstr_release /usr/src/debug/nfs-ganesha-4.0.2/support/refstr.c:24\n#3 0x7f542f79a9a9 in urcu_ref_put /usr/include/urcu/ref.h:68\n#4 0x7f542f79ab92 in gsh_refstr_put /usr/src/debug/nfs-ganesha-4.0.2/include/gsh_refstr.h:141\n#5 0x7f542f79d60f in copy_gsh_export /usr/src/debug/nfs-ganesha-4.0.2/support/exports.c:1042\n#6 0x7f542f79e539 in export_commit_common /usr/src/debug/nfs-ganesha-4.0.2/support/exports.c:1331\n#7 0x7f542f79f097 in update_export_commit /usr/src/debug/nfs-ganesha-4.0.2/support/exports.c:1610\n#8 0x7f542f72de55 in proc_block /usr/src/debug/nfs-ganesha-4.0.2/config_parsing/config_parsing.c:1416\n#9 0x7f542f72efd2 in load_config_from_parse /usr/src/debug/nfs-ganesha-4.0.2/config_parsing/config_parsing.c:2007\n#10 0x7f542f7a0267 in reread_exports /usr/src/debug/nfs-ganesha-4.0.2/support/exports.c:2372\n#11 0x7f542f717f7f in reread_config /usr/src/debug/nfs-ganesha-4.0.2/MainNFSD/nfs_init.c:196\n#12 0x7f542f71813d in sigmgr_thread /usr/src/debug/nfs-ganesha-4.0.2/MainNFSD/nfs_init.c:234\n#13 0x7f542fb69a87 in __asan_describe_address ??:?\npreviously allocated by thread T24 here:\n#0 0x7f542fb66119 in malloc ??:?\n#1 0x7f542f7c1a56 in gsh_refstr_alloc /usr/src/debug/nfs-ganesha-4.0.2/support/refstr.c:12\n#2 0x7f542f79ab21 in gsh_refstr_dup /usr/src/debug/nfs-ganesha-4.0.2/include/gsh_refstr.h:62\n#3 0x7f542f79d6ad in copy_gsh_export /usr/src/debug/nfs-ganesha-4.0.2/support/exports.c:1054 (discriminator 2)\n#4 0x7f542f79e539 in export_commit_common /usr/src/debug/nfs-ganesha-4.0.2/support/exports.c:1331\n#5 0x7f542f79f097 in update_export_commit /usr/src/debug/nfs-ganesha-4.0.2/support/exports.c:1610\n#6 0x7f542f72de55 in proc_block /usr/src/debug/nfs-ganesha-4.0.2/config_parsing/config_parsing.c:1416\n#7 0x7f542f72efd2 in load_config_from_parse /usr/src/debug/nfs-ganesha-4.0.2/config_parsing/config_parsing.c:2007\n#8 0x7f542f7a0267 in reread_exports /usr/src/debug/nfs-ganesha-4.0.2/support/exports.c:2372\n#9 0x7f542f717f7f in reread_config /usr/src/debug/nfs-ganesha-4.0.2/MainNFSD/nfs_init.c:196\n#10 0x7f542f71813d in sigmgr_thread /usr/src/debug/nfs-ganesha-4.0.2/MainNFSD/nfs_init.c:234\n#11 0x7f542fb69a87 in __asan_describe_address ??:?\nThread T1 created by T0 here:",
      "parentUuid": "19ae524d_96437097",
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df91b892_940a53a9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2022-06-09T14:33:09Z",
      "side": 1,
      "message": "Thanks. The problem is that update of an export\u0027s fullpath and pseudopath is not actually protected by any sort of lock. I\u0027m looking at the right way to do an RCU update. This path is the only update path and I think all the read paths are correct.\n\nSo the correction needs to be in copy_gsh_export.",
      "parentUuid": "2ca9c10b_03be8329",
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc2a9a45_2a0aef17",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1015367
      },
      "writtenOn": "2022-06-09T15:37:57Z",
      "side": 1,
      "message": "Added fix to reassign the pointer first and then free the old pointer, that should handle read paths accessing the old pointer, assuming reassign will",
      "parentUuid": "df91b892_940a53a9",
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6506cee6_5c33c851",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2022-06-15T18:32:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fc2a9a45_2a0aef17",
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c29eda9_94be29e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2022-06-01T15:03:28Z",
      "side": 1,
      "message": "Jeff could you review this please.",
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c7638c7_d76f3df2",
        "filename": "src/support/refstr.c",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1008909
      },
      "writtenOn": "2022-06-01T15:38:50Z",
      "side": 1,
      "message": "Doing this here seems wrong as not all of the gsh_refstr users are necessarily RCU-protected, and this could end up blocking when it\u0027s not actually needed.\n\nThat said, the RCU rules around gsh_refstr are not as clear as they should be. Some (most?) callers should be calling synchronize_rcu() before releasing the \"canonical\" reference on the object. Very few actually do this. Really, only the rados cluster backends handle this right, AFAICT.\n\nMaybe you\u0027re right and we should just make these things be properly RCU-managed so the upper layers don\u0027t need to deal with this. Instead of calling synchronize_rcu here though, I think we should use call_rcu.\n\nThat means that you\u0027d need to embed a rcu_head inside the gsh_refstr, but I\u0027d rather trade a little memory and avoid blocking a thread until the current rcu grace period ends.",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 2
      },
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e6b30f4_abc0ff72",
        "filename": "src/support/refstr.c",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1015367
      },
      "writtenOn": "2022-06-02T15:49:11Z",
      "side": 1,
      "message": "Thanks Jeff for review\nWe are hitting this race here as reported by address_sanitizer\nWe could end up releasing canonical reference in copy_gsh_export and free the pointer, simultaneously read thread might have got the reference.\n\nWe could use call_rcu also to avoid blocking.\n\nBut I am not sure why we have this assert in gsh_refstr_get()\n        /*                              \n         * The assumption is that the persistent reference to the object is\n         * only put after an RCU grace period has settled.\n         */      \n        if (!urcu_ref_get_unless_zero(\u0026gr-\u003egr_ref))\n                abort();\n\nWe could have zero ref, we should return NULL here or copy new pointer to old pointer before reclaiming old pointer, if we can\u0027t return NULL here.",
      "parentUuid": "6c7638c7_d76f3df2",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 2
      },
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e73c468_f6d4b4d8",
        "filename": "src/support/refstr.c",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1008909
      },
      "writtenOn": "2022-06-02T17:23:55Z",
      "side": 1,
      "message": "The assumption with gsh_refstr is that if you\u0027re using RCU, you should unhash the object, then call synchronize_rcu to ensure that no callers can find it, and only then drop the reference we hold on behalf of the hash.\n\nIf that\u0027s done, then an attempt to do a 0-\u003e1 transition on the counter should never happen and so we assert on that. Possibly we could relax that rule if there were some reason to allow this.",
      "parentUuid": "5e6b30f4_abc0ff72",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 2
      },
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3c66611_ab73aded",
        "filename": "src/support/refstr.c",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1008909
      },
      "writtenOn": "2022-06-09T15:40:10Z",
      "side": 1,
      "message": "To be clear, what you\u0027re proposing is to change how that works. Getting that right and still allowing RCU traversal of hashtables with these objects is the tricky part.\n\nIn fact, I wonder if the right fix here is to do something like this:\n\n```\ndiff --git a/src/support/exports.c b/src/support/exports.c\nindex ec0f6d394462..41ffa7e56376 100644\n--- a/src/support/exports.c\n+++ b/src/support/exports.c\n@@ -1026,18 +1026,28 @@ static inline void update_atomic_fields(struct gsh_export *export,\n static inline void copy_gsh_export(struct gsh_export *dest,\n                                   struct gsh_export *src)\n {\n+       struct gsh_refstr *fullpath, *pseudopath;\n+\n        /* Update atomic fields */\n        update_atomic_fields(dest, src);\n \n        /* Now take lock and swap out client list and export_perms... */\n        PTHREAD_RWLOCK_wrlock(\u0026dest-\u003elock);\n \n+       /* zero out old pointers and ensure that no one will see them */\n+       fullpath \u003d rcu_dereference(dest-\u003efullpath);\n+       pseudopath \u003d rcu_dereference(dest-\u003epseudopath);\n+       rcu_set_pointer(\u0026dest-\u003efullpath, NULL);\n+       rcu_set_pointer(\u0026dest-\u003epseudopath, NULL);\n+\n+       synchronize_rcu();\n+\n        /* Put references to old refstr */\n-       if (dest-\u003efullpath !\u003d NULL)\n-               gsh_refstr_put(dest-\u003efullpath);\n+       if (fullpath !\u003d NULL)\n+               gsh_refstr_put(fullpath);\n \n-       if (dest-\u003epseudopath !\u003d NULL)\n-               gsh_refstr_put(dest-\u003epseudopath);\n+       if (pseudopath !\u003d NULL)\n+               gsh_refstr_put(pseudopath);\n \n        /* Free old cfg_fullpath and cfg_pseudopath */\n        gsh_free(dest-\u003ecfg_fullpath);\n```",
      "parentUuid": "1e73c468_f6d4b4d8",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 2
      },
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08d82b8c_cce6bb5e",
        "filename": "src/support/refstr.c",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1003571
      },
      "writtenOn": "2022-06-15T18:32:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f3c66611_ab73aded",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 2
      },
      "revId": "11969debf25b382af2e0236113f905a76cb87b15",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}